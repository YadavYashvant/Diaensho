<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.PACKAGE_USAGE_STATS&quot;&#10;        tools:ignore=&quot;ProtectedPermissions&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.DiaryApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Diaensho&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.Diaensho&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;.service.HotwordDetectionService&quot;&#10;            android:foregroundServiceType=&quot;microphone&quot; /&gt;&#10;&#10;        &lt;provider&#10;            android:name=&quot;androidx.startup.InitializationProvider&quot;&#10;            android:authorities=&quot;${applicationId}.androidx-startup&quot;&#10;            tools:node=&quot;remove&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&lt;/manifest&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.PACKAGE_USAGE_STATS&quot;&#10;        tools:ignore=&quot;ProtectedPermissions&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_MICROPHONE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.DiaryApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Diaensho&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.Diaensho&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;.service.HotwordDetectionService&quot;&#10;            android:foregroundServiceType=&quot;microphone&quot; /&gt;&#10;&#10;        &lt;provider&#10;            android:name=&quot;androidx.startup.InitializationProvider&quot;&#10;            android:authorities=&quot;${applicationId}.androidx-startup&quot;&#10;            tools:node=&quot;remove&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/audio/SpeechToTextManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/audio/SpeechToTextManager.kt" />
              <option name="updatedContent" value="package com.example.diaensho.audio&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.speech.RecognitionListener&#10;import android.speech.RecognizerIntent&#10;import android.speech.SpeechRecognizer&#10;import android.util.Log&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import java.util.*&#10;&#10;@Singleton&#10;class SpeechToTextManager @Inject constructor(&#10;    private val context: Context&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;SpeechToTextManager&quot;&#10;        private const val RECOGNITION_TIMEOUT_MS = 30000L // 30 seconds&#10;        private const val SILENCE_TIMEOUT_MS = 5000L // 5 seconds of silence&#10;        private const val MAX_RETRY_ATTEMPTS = 3&#10;    }&#10;&#10;    private var speechRecognizer: SpeechRecognizer? = null&#10;    private var isListening = false&#10;    private var currentRetryCount = 0&#10;    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Main)&#10;    private var recognitionTimeoutJob: Job? = null&#10;    private var silenceTimeoutJob: Job? = null&#10;&#10;    private val _recognitionState = MutableStateFlow(RecognitionState.IDLE)&#10;    val recognitionState: StateFlow&lt;RecognitionState&gt; = _recognitionState&#10;&#10;    private val _partialResult = MutableStateFlow(&quot;&quot;)&#10;    val partialResult: StateFlow&lt;String&gt; = _partialResult&#10;&#10;    private val _finalResult = MutableStateFlow(&quot;&quot;)&#10;    val finalResult: StateFlow&lt;String&gt; = _finalResult&#10;&#10;    private val _confidence = MutableStateFlow(0f)&#10;    val confidence: StateFlow&lt;Float&gt; = _confidence&#10;&#10;    enum class RecognitionState {&#10;        IDLE, INITIALIZING, LISTENING, PROCESSING, ERROR, COMPLETED&#10;    }&#10;&#10;    data class RecognitionResult(&#10;        val text: String,&#10;        val confidence: Float,&#10;        val isPartial: Boolean = false&#10;    )&#10;&#10;    fun startListening(&#10;        onResult: (RecognitionResult) -&gt; Unit,&#10;        onError: (String) -&gt; Unit,&#10;        onComplete: () -&gt; Unit,&#10;        preferOffline: Boolean = false,&#10;        maxResults: Int = 5&#10;    ): Boolean {&#10;        if (isListening) {&#10;            Log.w(TAG, &quot;Already listening&quot;)&#10;            return false&#10;        }&#10;&#10;        if (!SpeechRecognizer.isRecognitionAvailable(context)) {&#10;            Log.e(TAG, &quot;Speech recognition not available&quot;)&#10;            onError(&quot;Speech recognition not available&quot;)&#10;            return false&#10;        }&#10;&#10;        return try {&#10;            _recognitionState.value = RecognitionState.INITIALIZING&#10;            _partialResult.value = &quot;&quot;&#10;            _finalResult.value = &quot;&quot;&#10;            _confidence.value = 0f&#10;&#10;            // Create and configure speech recognizer&#10;            speechRecognizer = SpeechRecognizer.createSpeechRecognizer(context)&#10;            &#10;            if (speechRecognizer == null) {&#10;                Log.e(TAG, &quot;Failed to create SpeechRecognizer&quot;)&#10;                onError(&quot;Failed to initialize speech recognition&quot;)&#10;                return false&#10;            }&#10;&#10;            val recognitionIntent = createRecognitionIntent(preferOffline, maxResults)&#10;            &#10;            speechRecognizer?.setRecognitionListener(object : RecognitionListener {&#10;                override fun onReadyForSpeech(params: Bundle?) {&#10;                    Log.d(TAG, &quot;Ready for speech&quot;)&#10;                    _recognitionState.value = RecognitionState.LISTENING&#10;                    startRecognitionTimeout(onError, onComplete)&#10;                    currentRetryCount = 0&#10;                }&#10;&#10;                override fun onBeginningOfSpeech() {&#10;                    Log.d(TAG, &quot;Beginning of speech detected&quot;)&#10;                    cancelSilenceTimeout()&#10;                    _recognitionState.value = RecognitionState.LISTENING&#10;                }&#10;&#10;                override fun onRmsChanged(rmsdB: Float) {&#10;                    // Normalize RMS to 0-1 range for UI feedback&#10;                    val normalizedLevel = (rmsdB + 40f) / 60f // Typical range is -40 to 20 dB&#10;                    _confidence.value = normalizedLevel.coerceIn(0f, 1f)&#10;                }&#10;&#10;                override fun onBufferReceived(buffer: ByteArray?) {&#10;                    // Audio buffer received - can be used for additional processing&#10;                }&#10;&#10;                override fun onEndOfSpeech() {&#10;                    Log.d(TAG, &quot;End of speech&quot;)&#10;                    _recognitionState.value = RecognitionState.PROCESSING&#10;                    startSilenceTimeout(onError, onComplete)&#10;                }&#10;&#10;                override fun onError(error: Int) {&#10;                    isListening = false&#10;                    cancelTimeouts()&#10;                    &#10;                    val errorMessage = when (error) {&#10;                        SpeechRecognizer.ERROR_AUDIO -&gt; &quot;Audio recording error&quot;&#10;                        SpeechRecognizer.ERROR_CLIENT -&gt; &quot;Client error&quot;&#10;                        SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS -&gt; &quot;Insufficient permissions&quot;&#10;                        SpeechRecognizer.ERROR_NETWORK -&gt; &quot;Network error&quot;&#10;                        SpeechRecognizer.ERROR_NETWORK_TIMEOUT -&gt; &quot;Network timeout&quot;&#10;                        SpeechRecognizer.ERROR_NO_MATCH -&gt; &quot;No speech detected&quot;&#10;                        SpeechRecognizer.ERROR_RECOGNIZER_BUSY -&gt; &quot;Recognizer busy&quot;&#10;                        SpeechRecognizer.ERROR_SERVER -&gt; &quot;Server error&quot;&#10;                        SpeechRecognizer.ERROR_SPEECH_TIMEOUT -&gt; &quot;Speech timeout&quot;&#10;                        else -&gt; &quot;Unknown error: $error&quot;&#10;                    }&#10;                    &#10;                    Log.e(TAG, &quot;Speech recognition error: $errorMessage&quot;)&#10;                    &#10;                    // Retry logic for certain errors&#10;                    if (shouldRetry(error) &amp;&amp; currentRetryCount &lt; MAX_RETRY_ATTEMPTS) {&#10;                        currentRetryCount++&#10;                        Log.i(TAG, &quot;Retrying recognition (attempt $currentRetryCount)&quot;)&#10;                        &#10;                        scope.launch {&#10;                            delay(1000) // Wait before retry&#10;                            if (!startListening(onResult, onError, onComplete, preferOffline, maxResults)) {&#10;                                _recognitionState.value = RecognitionState.ERROR&#10;                                onError(errorMessage)&#10;                            }&#10;                        }&#10;                    } else {&#10;                        _recognitionState.value = RecognitionState.ERROR&#10;                        onError(errorMessage)&#10;                    }&#10;                }&#10;&#10;                override fun onResults(results: Bundle?) {&#10;                    isListening = false&#10;                    cancelTimeouts()&#10;                    &#10;                    val matches = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)&#10;                    val confidenceScores = results?.getFloatArray(SpeechRecognizer.CONFIDENCE_SCORES)&#10;                    &#10;                    if (matches != null &amp;&amp; matches.isNotEmpty()) {&#10;                        val bestMatch = matches[0]&#10;                        val confidence = confidenceScores?.getOrNull(0) ?: 0f&#10;                        &#10;                        Log.d(TAG, &quot;Final result: $bestMatch (confidence: $confidence)&quot;)&#10;                        &#10;                        _finalResult.value = bestMatch&#10;                        _confidence.value = confidence&#10;                        _recognitionState.value = RecognitionState.COMPLETED&#10;                        &#10;                        onResult(RecognitionResult(bestMatch, confidence, isPartial = false))&#10;                        onComplete()&#10;                    } else {&#10;                        Log.w(TAG, &quot;No results received&quot;)&#10;                        _recognitionState.value = RecognitionState.ERROR&#10;                        onError(&quot;No speech detected&quot;)&#10;                    }&#10;                }&#10;&#10;                override fun onPartialResults(partialResults: Bundle?) {&#10;                    val matches = partialResults?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)&#10;                    val partial = matches?.firstOrNull() ?: &quot;&quot;&#10;                    &#10;                    if (partial.isNotEmpty()) {&#10;                        Log.d(TAG, &quot;Partial result: $partial&quot;)&#10;                        _partialResult.value = partial&#10;                        onResult(RecognitionResult(partial, 0f, isPartial = true))&#10;                        &#10;                        // Reset silence timeout as we're getting partial results&#10;                        resetSilenceTimeout(onError, onComplete)&#10;                    }&#10;                }&#10;&#10;                override fun onEvent(eventType: Int, params: Bundle?) {&#10;                    Log.d(TAG, &quot;Recognition event: $eventType&quot;)&#10;                }&#10;            })&#10;&#10;            isListening = true&#10;            speechRecognizer?.startListening(recognitionIntent)&#10;            Log.i(TAG, &quot;Speech recognition started&quot;)&#10;            true&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to start speech recognition&quot;, e)&#10;            _recognitionState.value = RecognitionState.ERROR&#10;            onError(&quot;Failed to start speech recognition: ${e.message}&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun createRecognitionIntent(preferOffline: Boolean, maxResults: Int): Intent {&#10;        return Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {&#10;            putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)&#10;            putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.getDefault())&#10;            putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS, true)&#10;            putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, maxResults)&#10;            putExtra(RecognizerIntent.EXTRA_PREFER_OFFLINE, preferOffline)&#10;            putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE, context.packageName)&#10;            &#10;            // Enhanced audio settings for better recognition&#10;            putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_COMPLETE_SILENCE_LENGTH_MILLIS, SILENCE_TIMEOUT_MS)&#10;            putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_POSSIBLY_COMPLETE_SILENCE_LENGTH_MILLIS, SILENCE_TIMEOUT_MS / 2)&#10;            putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_MINIMUM_LENGTH_MILLIS, 1000)&#10;            &#10;            // Request confidence scores&#10;            putExtra(RecognizerIntent.EXTRA_CONFIDENCE_SCORES, true)&#10;        }&#10;    }&#10;&#10;    private fun shouldRetry(error: Int): Boolean {&#10;        return when (error) {&#10;            SpeechRecognizer.ERROR_NETWORK,&#10;            SpeechRecognizer.ERROR_NETWORK_TIMEOUT,&#10;            SpeechRecognizer.ERROR_SERVER,&#10;            SpeechRecognizer.ERROR_RECOGNIZER_BUSY -&gt; true&#10;            else -&gt; false&#10;        }&#10;    }&#10;&#10;    private fun startRecognitionTimeout(onError: (String) -&gt; Unit, onComplete: () -&gt; Unit) {&#10;        recognitionTimeoutJob = scope.launch {&#10;            delay(RECOGNITION_TIMEOUT_MS)&#10;            if (isListening) {&#10;                Log.w(TAG, &quot;Recognition timeout&quot;)&#10;                stopListening()&#10;                _recognitionState.value = RecognitionState.ERROR&#10;                onError(&quot;Recognition timed out&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startSilenceTimeout(onError: (String) -&gt; Unit, onComplete: () -&gt; Unit) {&#10;        silenceTimeoutJob = scope.launch {&#10;            delay(SILENCE_TIMEOUT_MS)&#10;            if (isListening) {&#10;                Log.i(TAG, &quot;Silence timeout - completing recognition&quot;)&#10;                stopListening()&#10;                if (_partialResult.value.isNotEmpty()) {&#10;                    _finalResult.value = _partialResult.value&#10;                    _recognitionState.value = RecognitionState.COMPLETED&#10;                    onComplete()&#10;                } else {&#10;                    _recognitionState.value = RecognitionState.ERROR&#10;                    onError(&quot;No speech detected after silence&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun resetSilenceTimeout(onError: (String) -&gt; Unit, onComplete: () -&gt; Unit) {&#10;        cancelSilenceTimeout()&#10;        startSilenceTimeout(onError, onComplete)&#10;    }&#10;&#10;    private fun cancelTimeouts() {&#10;        recognitionTimeoutJob?.cancel()&#10;        silenceTimeoutJob?.cancel()&#10;    }&#10;&#10;    private fun cancelSilenceTimeout() {&#10;        silenceTimeoutJob?.cancel()&#10;    }&#10;&#10;    fun stopListening() {&#10;        if (!isListening) return&#10;&#10;        isListening = false&#10;        cancelTimeouts()&#10;        &#10;        try {&#10;            speechRecognizer?.cancel()&#10;            speechRecognizer?.destroy()&#10;            speechRecognizer = null&#10;            &#10;            if (_recognitionState.value != RecognitionState.COMPLETED) {&#10;                _recognitionState.value = RecognitionState.IDLE&#10;            }&#10;            &#10;            Log.i(TAG, &quot;Speech recognition stopped&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error stopping speech recognition&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun release() {&#10;        stopListening()&#10;        scope.cancel()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/data/repository/MainRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/data/repository/MainRepository.kt" />
              <option name="originalContent" value="package com.example.diaensho.data.repository&#10;&#10;import com.example.diaensho.data.db.dao.AppUsageStatDao&#10;import com.example.diaensho.data.db.dao.DiaryEntryDao&#10;import com.example.diaensho.data.db.entity.AppUsageStatEntity&#10;import com.example.diaensho.data.db.entity.DiaryEntryEntity&#10;import com.example.diaensho.data.network.DiaryApiService&#10;import com.example.diaensho.data.network.model.AppUsageStatDto&#10;import com.example.diaensho.data.network.model.DailySummaryDto&#10;import com.example.diaensho.data.network.model.DiaryEntryDto&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class MainRepository @Inject constructor(&#10;    private val diaryEntryDao: DiaryEntryDao,&#10;    private val appUsageStatDao: AppUsageStatDao,&#10;    private val apiService: DiaryApiService&#10;) {&#10;    // Diary Entry Operations&#10;    suspend fun addDiaryEntry(text: String) {&#10;        val entry = DiaryEntryEntity(&#10;            text = text,&#10;            timestamp = LocalDateTime.now()&#10;        )&#10;        diaryEntryDao.insert(entry)&#10;    }&#10;&#10;    fun getDiaryEntries(): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        return diaryEntryDao.getAllEntries()&#10;    }&#10;&#10;    fun getDiaryEntriesForDate(date: LocalDate): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        val startOfDay = date.atStartOfDay()&#10;        val endOfDay = date.plusDays(1).atStartOfDay()&#10;        return diaryEntryDao.getEntriesBetween(startOfDay, endOfDay)&#10;    }&#10;&#10;    fun getDiaryEntriesForDateRange(startDate: LocalDate, endDate: LocalDate): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        val startDateTime = startDate.atStartOfDay()&#10;        val endDateTime = endDate.plusDays(1).atStartOfDay()&#10;        return diaryEntryDao.getEntriesBetween(startDateTime, endDateTime)&#10;    }&#10;&#10;    // App Usage Stats Operations&#10;    suspend fun saveAppUsageStats(stats: List&lt;AppUsageStatEntity&gt;) {&#10;        appUsageStatDao.insertAll(stats)&#10;    }&#10;&#10;    fun getAppUsageStatsForDate(date: LocalDate): Flow&lt;List&lt;AppUsageStatEntity&gt;&gt; {&#10;        return appUsageStatDao.getUsageStatsForDate(date)&#10;    }&#10;&#10;    // Enhanced Synchronization Operations&#10;    suspend fun syncUnsyncedEntries() {&#10;        val unsyncedEntries = diaryEntryDao.getUnsyncedEntries()&#10;        if (unsyncedEntries.isNotEmpty()) {&#10;            try {&#10;                val dtos = unsyncedEntries.map { entity -&gt;&#10;                    DiaryEntryDto(&#10;                        text = entity.text,&#10;                        timestamp = entity.timestamp.toString()&#10;                    )&#10;                }&#10;                val syncedEntries = dtos.map { dto -&gt;&#10;                    apiService.createEntry(dto)&#10;                }&#10;                diaryEntryDao.markAsSynced(unsyncedEntries.map { it.id })&#10;            } catch (e: Exception) {&#10;                throw RuntimeException(&quot;Failed to sync diary entries&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun syncUnsyncedStats() {&#10;        val unsyncedStats = appUsageStatDao.getUnsyncedStats()&#10;        if (unsyncedStats.isNotEmpty()) {&#10;            try {&#10;                val dtos = unsyncedStats.map { stat -&gt;&#10;                    AppUsageStatDto(&#10;                        packageName = stat.packageName,&#10;                        totalTimeInForeground = stat.totalTimeInForeground,&#10;                        date = stat.date.toString()&#10;                    )&#10;                }&#10;                apiService.uploadUsageStats(dtos)&#10;                appUsageStatDao.markAsSynced(unsyncedStats.map { it.id })&#10;            } catch (e: Exception) {&#10;                throw RuntimeException(&quot;Failed to sync usage stats&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    // New Daily Summary Operations&#10;    suspend fun getDailySummary(date: LocalDate): Result&lt;DailySummaryDto&gt; {&#10;        return try {&#10;            val summary = apiService.getDailySummary(date.toString())&#10;            Result.success(summary)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    fun searchEntries(query: String, startDate: LocalDate, endDate: LocalDate): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        return diaryEntryDao.getEntriesBetween(&#10;            startTime = startDate.atStartOfDay(),&#10;            endTime = endDate.plusDays(1).atStartOfDay()&#10;        ).map { entries -&gt;&#10;            entries.filter { it.text.contains(query, ignoreCase = true) }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.data.repository&#10;&#10;import android.util.Log&#10;import com.example.diaensho.data.db.dao.AppUsageStatDao&#10;import com.example.diaensho.data.db.dao.DiaryEntryDao&#10;import com.example.diaensho.data.db.entity.AppUsageStatEntity&#10;import com.example.diaensho.data.db.entity.DiaryEntryEntity&#10;import com.example.diaensho.data.network.DiaryApiService&#10;import com.example.diaensho.data.network.model.AppUsageStatDto&#10;import com.example.diaensho.data.network.model.DailySummaryDto&#10;import com.example.diaensho.data.network.model.DiaryEntryDto&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class MainRepository @Inject constructor(&#10;    private val diaryEntryDao: DiaryEntryDao,&#10;    private val appUsageStatDao: AppUsageStatDao,&#10;    private val apiService: DiaryApiService&#10;) {&#10;    // Diary Entry Operations&#10;    suspend fun addDiaryEntry(text: String) {&#10;        Log.d(&quot;MainRepository&quot;, &quot;Attempting to save diary entry: '$text'&quot;)&#10;        val entry = DiaryEntryEntity(&#10;            text = text,&#10;            timestamp = LocalDateTime.now()&#10;        )&#10;        try {&#10;            val entryId = diaryEntryDao.insert(entry)&#10;            Log.i(&quot;MainRepository&quot;, &quot;Diary entry saved successfully with ID: $entryId, content: '$text'&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;MainRepository&quot;, &quot;Failed to save diary entry: '$text'&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;&#10;    fun getDiaryEntries(): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        return diaryEntryDao.getAllEntries()&#10;    }&#10;&#10;    fun getDiaryEntriesForDate(date: LocalDate): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        val startOfDay = date.atStartOfDay()&#10;        val endOfDay = date.plusDays(1).atStartOfDay()&#10;        return diaryEntryDao.getEntriesBetween(startOfDay, endOfDay)&#10;    }&#10;&#10;    fun getDiaryEntriesForDateRange(startDate: LocalDate, endDate: LocalDate): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        val startDateTime = startDate.atStartOfDay()&#10;        val endDateTime = endDate.plusDays(1).atStartOfDay()&#10;        return diaryEntryDao.getEntriesBetween(startDateTime, endDateTime)&#10;    }&#10;&#10;    // App Usage Stats Operations&#10;    suspend fun saveAppUsageStats(stats: List&lt;AppUsageStatEntity&gt;) {&#10;        appUsageStatDao.insertAll(stats)&#10;    }&#10;&#10;    fun getAppUsageStatsForDate(date: LocalDate): Flow&lt;List&lt;AppUsageStatEntity&gt;&gt; {&#10;        return appUsageStatDao.getUsageStatsForDate(date)&#10;    }&#10;&#10;    // Enhanced Synchronization Operations&#10;    suspend fun syncUnsyncedEntries() {&#10;        val unsyncedEntries = diaryEntryDao.getUnsyncedEntries()&#10;        if (unsyncedEntries.isNotEmpty()) {&#10;            try {&#10;                val dtos = unsyncedEntries.map { entity -&gt;&#10;                    DiaryEntryDto(&#10;                        text = entity.text,&#10;                        timestamp = entity.timestamp.toString()&#10;                    )&#10;                }&#10;                val syncedEntries = dtos.map { dto -&gt;&#10;                    apiService.createEntry(dto)&#10;                }&#10;                diaryEntryDao.markAsSynced(unsyncedEntries.map { it.id })&#10;            } catch (e: Exception) {&#10;                throw RuntimeException(&quot;Failed to sync diary entries&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun syncUnsyncedStats() {&#10;        val unsyncedStats = appUsageStatDao.getUnsyncedStats()&#10;        if (unsyncedStats.isNotEmpty()) {&#10;            try {&#10;                val dtos = unsyncedStats.map { stat -&gt;&#10;                    AppUsageStatDto(&#10;                        packageName = stat.packageName,&#10;                        totalTimeInForeground = stat.totalTimeInForeground,&#10;                        date = stat.date.toString()&#10;                    )&#10;                }&#10;                apiService.uploadUsageStats(dtos)&#10;                appUsageStatDao.markAsSynced(unsyncedStats.map { it.id })&#10;            } catch (e: Exception) {&#10;                throw RuntimeException(&quot;Failed to sync usage stats&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    // New Daily Summary Operations&#10;    suspend fun getDailySummary(date: LocalDate): Result&lt;DailySummaryDto&gt; {&#10;        return try {&#10;            val summary = apiService.getDailySummary(date.toString())&#10;            Result.success(summary)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    fun searchEntries(query: String, startDate: LocalDate, endDate: LocalDate): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        return diaryEntryDao.getEntriesBetween(&#10;            startTime = startDate.atStartOfDay(),&#10;            endTime = endDate.plusDays(1).atStartOfDay()&#10;        ).map { entries -&gt;&#10;            entries.filter { it.text.contains(query, ignoreCase = true) }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/di/AudioModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/di/AudioModule.kt" />
              <option name="updatedContent" value="package com.example.diaensho.di&#10;&#10;import android.content.Context&#10;import com.example.diaensho.audio.AudioManager&#10;import com.example.diaensho.audio.SpeechToTextManager&#10;import com.example.diaensho.audio.WakeWordDetector&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object AudioModule {&#10;    &#10;    @Provides&#10;    @Singleton&#10;    fun provideAudioManager(&#10;        @ApplicationContext context: Context&#10;    ): AudioManager {&#10;        return AudioManager(context)&#10;    }&#10;    &#10;    @Provides&#10;    @Singleton&#10;    fun provideSpeechToTextManager(&#10;        @ApplicationContext context: Context&#10;    ): SpeechToTextManager {&#10;        return SpeechToTextManager(context)&#10;    }&#10;    &#10;    @Provides&#10;    @Singleton&#10;    fun provideWakeWordDetector(&#10;        @ApplicationContext context: Context,&#10;        audioManager: AudioManager&#10;    ): WakeWordDetector {&#10;        return WakeWordDetector(context, audioManager)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/ui/screen/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/ui/screen/HomeScreen.kt" />
              <option name="originalContent" value="package com.example.diaensho.ui.screen&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.KeyboardArrowLeft&#10;import androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.ArrowForward&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.diaensho.viewmodel.HomeViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.diaensho.data.db.entity.AppUsageStatEntity&#10;import com.example.diaensho.data.db.entity.DiaryEntryEntity&#10;import java.time.LocalDate&#10;import java.time.format.DateTimeFormatter&#10;import java.util.concurrent.TimeUnit&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    homeViewModel: HomeViewModel = viewModel(),&#10;    selectedDate: LocalDate,&#10;    onDateChange: (LocalDate) -&gt; Unit,&#10;    onSearchClick: () -&gt; Unit&#10;) {&#10;    val entries by homeViewModel.entries.collectAsStateWithLifecycle()&#10;    val appUsageStats by homeViewModel.appUsageStats.collectAsStateWithLifecycle()&#10;&#10;    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {&#10;        // Date selector&#10;        DateSelector(&#10;            selectedDate = selectedDate,&#10;            onPreviousDay = { onDateChange(selectedDate.minusDays(1)) },&#10;            onNextDay = { onDateChange(selectedDate.plusDays(1)) }&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // App usage stats summary&#10;        AppUsageSection(appUsageStats)&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // Diary entries&#10;        Text(&#10;            text = &quot;Diary Entries&quot;,&#10;            style = MaterialTheme.typography.titleMedium&#10;        )&#10;&#10;        LazyColumn(&#10;            modifier = Modifier.weight(1f),&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            items(entries) { entry -&gt;&#10;                DiaryEntryCard(entry)&#10;            }&#10;        }&#10;&#10;        // Search button&#10;        Button(&#10;            onClick = onSearchClick,&#10;            modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp)&#10;        ) {&#10;            Text(&quot;Search Entries&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun DateSelector(&#10;    selectedDate: LocalDate,&#10;    onPreviousDay: () -&gt; Unit,&#10;    onNextDay: () -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.SpaceBetween,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        IconButton(onClick = onPreviousDay) {&#10;            Icon(Icons.AutoMirrored.Default.KeyboardArrowLeft, &quot;Previous day&quot;)&#10;        }&#10;&#10;        Text(&#10;            text = selectedDate.format(DateTimeFormatter.ofPattern(&quot;MMMM d, yyyy&quot;)),&#10;            style = MaterialTheme.typography.titleMedium&#10;        )&#10;&#10;        IconButton(onClick = onNextDay) {&#10;            Icon(Icons.AutoMirrored.Default.KeyboardArrowRight, &quot;Next day&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AppUsageSection(stats: List&lt;AppUsageStatEntity&gt;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;App Usage Summary&quot;,&#10;                style = MaterialTheme.typography.titleMedium&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            stats.take(5).forEach { stat -&gt;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(stat.packageName.split(&quot;.&quot;).last())&#10;                    Text(formatDuration(stat.totalTimeInForeground))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun DiaryEntryCard(entry: DiaryEntryEntity) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Text(&#10;                text = entry.text,&#10;                style = MaterialTheme.typography.bodyMedium&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = entry.timestamp.format(DateTimeFormatter.ofPattern(&quot;HH:mm&quot;)),&#10;                style = MaterialTheme.typography.bodySmall&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatDuration(millis: Long): String {&#10;    val hours = TimeUnit.MILLISECONDS.toHours(millis)&#10;    val minutes = TimeUnit.MILLISECONDS.toMinutes(millis) % 60&#10;    return when {&#10;        hours &gt; 0 -&gt; &quot;${hours}h ${minutes}m&quot;&#10;        minutes &gt; 0 -&gt; &quot;${minutes}m&quot;&#10;        else -&gt; &quot;&lt; 1m&quot;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.ui.screen&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.KeyboardArrowLeft&#10;import androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.ArrowForward&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.diaensho.viewmodel.HomeViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.diaensho.data.db.entity.AppUsageStatEntity&#10;import com.example.diaensho.data.db.entity.DiaryEntryEntity&#10;import java.time.LocalDate&#10;import java.time.format.DateTimeFormatter&#10;import java.util.concurrent.TimeUnit&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    homeViewModel: HomeViewModel = viewModel(),&#10;    selectedDate: LocalDate,&#10;    onDateChange: (LocalDate) -&gt; Unit,&#10;    onSearchClick: () -&gt; Unit&#10;) {&#10;    val entries by homeViewModel.entries.collectAsStateWithLifecycle()&#10;    val appUsageStats by homeViewModel.appUsageStats.collectAsStateWithLifecycle()&#10;&#10;    // Update ViewModel when date changes&#10;    LaunchedEffect(selectedDate) {&#10;        homeViewModel.loadDataForDate(selectedDate)&#10;    }&#10;&#10;    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {&#10;        // Date selector&#10;        DateSelector(&#10;            selectedDate = selectedDate,&#10;            onPreviousDay = { onDateChange(selectedDate.minusDays(1)) },&#10;            onNextDay = { onDateChange(selectedDate.plusDays(1)) }&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // App usage stats summary&#10;        AppUsageSection(appUsageStats)&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // Diary entries&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;Diary Entries&quot;,&#10;                style = MaterialTheme.typography.titleMedium&#10;            )&#10;            Text(&#10;                text = &quot;${entries.size} entries&quot;,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;        if (entries.isEmpty()) {&#10;            // Show empty state&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                )&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;No diary entries for this day&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;Say 'computer' followed by your thoughts to create an entry&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            LazyColumn(&#10;                modifier = Modifier.weight(1f),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                items(entries, key = { it.id }) { entry -&gt;&#10;                    DiaryEntryCard(entry)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Search button&#10;        Button(&#10;            onClick = onSearchClick,&#10;            modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp)&#10;        ) {&#10;            Text(&quot;Search Entries&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun DateSelector(&#10;    selectedDate: LocalDate,&#10;    onPreviousDay: () -&gt; Unit,&#10;    onNextDay: () -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        horizontalArrangement = Arrangement.SpaceBetween,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        IconButton(onClick = onPreviousDay) {&#10;            Icon(Icons.AutoMirrored.Default.KeyboardArrowLeft, &quot;Previous day&quot;)&#10;        }&#10;&#10;        Text(&#10;            text = selectedDate.format(DateTimeFormatter.ofPattern(&quot;MMMM d, yyyy&quot;)),&#10;            style = MaterialTheme.typography.titleMedium&#10;        )&#10;&#10;        IconButton(onClick = onNextDay) {&#10;            Icon(Icons.AutoMirrored.Default.KeyboardArrowRight, &quot;Next day&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AppUsageSection(stats: List&lt;AppUsageStatEntity&gt;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;App Usage Summary&quot;,&#10;                style = MaterialTheme.typography.titleMedium&#10;            )&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            stats.take(5).forEach { stat -&gt;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(stat.packageName.split(&quot;.&quot;).last())&#10;                    Text(formatDuration(stat.totalTimeInForeground))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun DiaryEntryCard(entry: DiaryEntryEntity) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Text(&#10;                text = entry.text,&#10;                style = MaterialTheme.typography.bodyMedium&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = entry.timestamp.format(DateTimeFormatter.ofPattern(&quot;HH:mm&quot;)),&#10;                style = MaterialTheme.typography.bodySmall&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatDuration(millis: Long): String {&#10;    val hours = TimeUnit.MILLISECONDS.toHours(millis)&#10;    val minutes = TimeUnit.MILLISECONDS.toMinutes(millis) % 60&#10;    return when {&#10;        hours &gt; 0 -&gt; &quot;${hours}h ${minutes}m&quot;&#10;        minutes &gt; 0 -&gt; &quot;${minutes}m&quot;&#10;        else -&gt; &quot;&lt; 1m&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/ui/screen/OnboardingScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/ui/screen/OnboardingScreen.kt" />
              <option name="originalContent" value="package com.example.diaensho.ui.screen&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.diaensho.util.PowerManagerHelper&#10;import com.example.diaensho.viewmodel.OnboardingViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;&#10;@Composable&#10;fun OnboardingScreen(&#10;    onboardingViewModel: OnboardingViewModel = viewModel(),&#10;    onPermissionsGranted: () -&gt; Unit,&#10;    onRequestMicPermission: () -&gt; Unit,&#10;    onRequestUsageStatsPermission: () -&gt; Unit&#10;) {&#10;    val uiState by onboardingViewModel.uiState.collectAsStateWithLifecycle()&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            text = &quot;Welcome to Cogniscribe!&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        Text(&#10;            text = &quot;Please grant the following permissions to enable voice diary entries:&quot;,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;        // Microphone Permission&#10;        PermissionButton(&#10;            text = if (uiState.microphonePermissionGranted) &quot;✓ Microphone Granted&quot; else &quot;Grant Microphone Permission&quot;,&#10;            onClick = onRequestMicPermission,&#10;            enabled = !uiState.microphonePermissionGranted,&#10;            description = &quot;Required for voice recognition&quot;&#10;        )&#10;&#10;        // Usage Stats Permission&#10;        PermissionButton(&#10;            text = if (uiState.usageStatsPermissionGranted) &quot;✓ Usage Stats Granted&quot; else &quot;Grant Usage Stats Permission&quot;,&#10;            onClick = onRequestUsageStatsPermission,&#10;            enabled = !uiState.usageStatsPermissionGranted,&#10;            description = &quot;Required for app usage tracking&quot;&#10;        )&#10;&#10;        // Battery Optimization Permission&#10;        PermissionButton(&#10;            text = if (uiState.batteryOptimizationDisabled) &quot;✓ Battery Optimization Disabled&quot; else &quot;Disable Battery Optimization&quot;,&#10;            onClick = {&#10;                context.startActivity(onboardingViewModel.getBatteryOptimizationIntent())&#10;            },&#10;            enabled = !uiState.batteryOptimizationDisabled,&#10;            description = &quot;Required for reliable voice detection&quot;&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        Button(&#10;            onClick = onPermissionsGranted,&#10;            enabled = uiState.allPermissionsGranted,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&quot;Continue&quot;)&#10;        }&#10;&#10;        if (!uiState.allPermissionsGranted) {&#10;            Text(&#10;                text = &quot;Please grant all permissions to continue&quot;,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = MaterialTheme.colorScheme.error&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PermissionButton(&#10;    text: String,&#10;    onClick: () -&gt; Unit,&#10;    enabled: Boolean,&#10;    description: String&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Button(&#10;            onClick = onClick,&#10;            enabled = enabled,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(text)&#10;        }&#10;        if (enabled) {&#10;            Text(&#10;                text = description,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.ui.screen&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.diaensho.viewmodel.OnboardingViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;&#10;@Composable&#10;fun OnboardingScreen(&#10;    onboardingViewModel: OnboardingViewModel = viewModel(),&#10;    onPermissionsGranted: () -&gt; Unit,&#10;    onRequestMicPermission: () -&gt; Unit,&#10;    onRequestUsageStatsPermission: () -&gt; Unit&#10;) {&#10;    val uiState by onboardingViewModel.uiState.collectAsStateWithLifecycle()&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            text = &quot;Welcome to Cogniscribe!&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        Text(&#10;            text = &quot;Please grant the following permissions to enable voice diary entries:&quot;,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;        // Microphone Permission&#10;        PermissionButton(&#10;            text = if (uiState.microphonePermissionGranted) &quot;✓ Microphone Granted&quot; else &quot;Grant Microphone Permission&quot;,&#10;            onClick = onRequestMicPermission,&#10;            enabled = !uiState.microphonePermissionGranted,&#10;            description = &quot;Required for voice recognition&quot;&#10;        )&#10;&#10;        // Usage Stats Permission&#10;        PermissionButton(&#10;            text = if (uiState.usageStatsPermissionGranted) &quot;✓ Usage Stats Granted&quot; else &quot;Grant Usage Stats Permission&quot;,&#10;            onClick = onRequestUsageStatsPermission,&#10;            enabled = !uiState.usageStatsPermissionGranted,&#10;            description = &quot;Required for app usage tracking&quot;&#10;        )&#10;&#10;        // Battery Optimization Permission&#10;        PermissionButton(&#10;            text = if (uiState.batteryOptimizationDisabled) &quot;✓ Battery Optimization Disabled&quot; else &quot;Disable Battery Optimization&quot;,&#10;            onClick = {&#10;                context.startActivity(onboardingViewModel.getBatteryOptimizationIntent())&#10;            },&#10;            enabled = !uiState.batteryOptimizationDisabled,&#10;            description = &quot;Required for reliable voice detection&quot;&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        Button(&#10;            onClick = onPermissionsGranted,&#10;            enabled = uiState.allPermissionsGranted,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&quot;Continue&quot;)&#10;        }&#10;&#10;        if (!uiState.allPermissionsGranted) {&#10;            Text(&#10;                text = &quot;Please grant all permissions to continue&quot;,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = MaterialTheme.colorScheme.error&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PermissionButton(&#10;    text: String,&#10;    onClick: () -&gt; Unit,&#10;    enabled: Boolean,&#10;    description: String&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Button(&#10;            onClick = onClick,&#10;            enabled = enabled,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(text)&#10;        }&#10;        if (enabled) {&#10;            Text(&#10;                text = description,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/viewmodel/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/viewmodel/HomeViewModel.kt" />
              <option name="originalContent" value="package com.example.diaensho.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.diaensho.data.db.entity.DiaryEntryEntity&#10;import com.example.diaensho.data.db.entity.AppUsageStatEntity&#10;import com.example.diaensho.data.repository.MainRepository&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val repository: MainRepository&#10;) : ViewModel() {&#10;    private val _entries = MutableStateFlow&lt;List&lt;DiaryEntryEntity&gt;&gt;(emptyList())&#10;    val entries: StateFlow&lt;List&lt;DiaryEntryEntity&gt;&gt; = _entries.asStateFlow()&#10;&#10;    private val _appUsageStats = MutableStateFlow&lt;List&lt;AppUsageStatEntity&gt;&gt;(emptyList())&#10;    val appUsageStats: StateFlow&lt;List&lt;AppUsageStatEntity&gt;&gt; = _appUsageStats.asStateFlow()&#10;&#10;    private var currentDate: LocalDate = LocalDate.now()&#10;&#10;    init {&#10;        loadDataForDate(currentDate)&#10;    }&#10;&#10;    fun loadDataForDate(date: LocalDate) {&#10;        currentDate = date&#10;        viewModelScope.launch {&#10;            // Load diary entries&#10;            repository.getDiaryEntriesForDate(date).collect {&#10;                _entries.value = it&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            // Load app usage stats&#10;            repository.getAppUsageStatsForDate(date).collect {&#10;                _appUsageStats.value = it.sortedByDescending { stat -&gt; stat.totalTimeInForeground }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.viewmodel&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.diaensho.data.db.entity.DiaryEntryEntity&#10;import com.example.diaensho.data.db.entity.AppUsageStatEntity&#10;import com.example.diaensho.data.repository.MainRepository&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val repository: MainRepository&#10;) : ViewModel() {&#10;    private val _entries = MutableStateFlow&lt;List&lt;DiaryEntryEntity&gt;&gt;(emptyList())&#10;    val entries: StateFlow&lt;List&lt;DiaryEntryEntity&gt;&gt; = _entries.asStateFlow()&#10;&#10;    private val _appUsageStats = MutableStateFlow&lt;List&lt;AppUsageStatEntity&gt;&gt;(emptyList())&#10;    val appUsageStats: StateFlow&lt;List&lt;AppUsageStatEntity&gt;&gt; = _appUsageStats.asStateFlow()&#10;&#10;    private var currentDate: LocalDate = LocalDate.now()&#10;&#10;    init {&#10;        Log.d(&quot;HomeViewModel&quot;, &quot;Initializing HomeViewModel for date: $currentDate&quot;)&#10;        loadDataForDate(currentDate)&#10;    }&#10;&#10;    fun loadDataForDate(date: LocalDate) {&#10;        Log.d(&quot;HomeViewModel&quot;, &quot;Loading data for date: $date&quot;)&#10;        currentDate = date&#10;&#10;        viewModelScope.launch {&#10;            // Load diary entries&#10;            Log.d(&quot;HomeViewModel&quot;, &quot;Starting to load diary entries for: $date&quot;)&#10;            repository.getDiaryEntriesForDate(date).collect { entriesList -&gt;&#10;                Log.d(&quot;HomeViewModel&quot;, &quot;Received ${entriesList.size} diary entries for $date&quot;)&#10;                entriesList.forEach { entry -&gt;&#10;                    Log.v(&quot;HomeViewModel&quot;, &quot;Entry ID: ${entry.id}, Text: '${entry.text.take(50)}...', Time: ${entry.timestamp}&quot;)&#10;                }&#10;                _entries.value = entriesList&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            // Load app usage stats&#10;            Log.d(&quot;HomeViewModel&quot;, &quot;Starting to load app usage stats for: $date&quot;)&#10;            repository.getAppUsageStatsForDate(date).collect { statsList -&gt;&#10;                Log.d(&quot;HomeViewModel&quot;, &quot;Received ${statsList.size} app usage stats for $date&quot;)&#10;                _appUsageStats.value = statsList.sortedByDescending { stat -&gt; stat.totalTimeInForeground }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>