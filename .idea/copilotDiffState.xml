<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;//    kotlin(&quot;kapt&quot;)&#10;    alias(libs.plugins.hilt.android)&#10;    alias(libs.plugins.ksp)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.diaensho&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.diaensho&quot;&#10;        minSdk = 26&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = &quot;1.5.3&quot;&#10;    }&#10;}&#10;&#10;ksp {&#10;    arg(&quot;room.schemaLocation&quot;, &quot;$projectDir/schemas&quot;)&#10;    arg(&quot;room.incremental&quot;, &quot;true&quot;)&#10;    arg(&quot;room.expandProjection&quot;, &quot;true&quot;)&#10;}&#10;&#10;dependencies {&#10;    // AndroidX Core&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-runtime-compose:2.7.0&quot;)&#10;    implementation(&quot;androidx.compose.runtime:runtime-livedata&quot;)&#10;&#10;    // Hilt&#10;    implementation(libs.hilt.android)&#10;    ksp(libs.hilt.compiler)&#10;    implementation(libs.androidx.hilt.navigation.compose)&#10;&#10;    // Room&#10;    implementation(&quot;androidx.room:room-runtime:2.6.1&quot;)&#10;    ksp(&quot;androidx.room:room-compiler:2.6.1&quot;)&#10;    implementation(&quot;androidx.room:room-ktx:2.6.1&quot;)&#10;&#10;    // Retrofit &amp; Network&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-moshi:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;)&#10;    implementation(&quot;com.squareup.moshi:moshi-kotlin:1.15.0&quot;)&#10;    ksp(&quot;com.squareup.moshi:moshi-kotlin-codegen:1.15.0&quot;)&#10;&#10;    // WorkManager&#10;    implementation(&quot;androidx.work:work-runtime-ktx:2.9.0&quot;)&#10;    implementation(&quot;androidx.hilt:hilt-work:1.1.0&quot;)&#10;    ksp(&quot;androidx.hilt:hilt-compiler:1.1.0&quot;) // Uncomment and fix this line&#10;&#10;&#10;    // Coroutines&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-play-services:1.7.3&quot;)&#10;&#10;    // Testing&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;&#10;    // Porcupine Wake Word Engine (Free tier)&#10;    implementation(&quot;ai.picovoice:porcupine-android:3.0.1&quot;)&#10;&#10;    // Additional audio processing&#10;    implementation(&quot;com.github.wendykierp:JTransforms:3.1&quot;)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;//    kotlin(&quot;kapt&quot;)&#10;    alias(libs.plugins.hilt.android)&#10;    alias(libs.plugins.ksp)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.diaensho&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.diaensho&quot;&#10;        minSdk = 26&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;        &#10;        // Read Porcupine access key from local.properties&#10;        val localProperties = java.util.Properties()&#10;        val localPropertiesFile = rootProject.file(&quot;local.properties&quot;)&#10;        if (localPropertiesFile.exists()) {&#10;            localPropertiesFile.inputStream().use { localProperties.load(it) }&#10;        }&#10;        val porcupineAccessKey = localProperties.getProperty(&quot;porcupine.access.key&quot;) ?: &quot;&quot;&#10;        buildConfigField(&quot;String&quot;, &quot;PORCUPINE_ACCESS_KEY&quot;, &quot;\&quot;$porcupineAccessKey\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true // Enable BuildConfig generation&#10;    }&#10;&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = &quot;1.5.3&quot;&#10;    }&#10;}&#10;&#10;ksp {&#10;    arg(&quot;room.schemaLocation&quot;, &quot;$projectDir/schemas&quot;)&#10;    arg(&quot;room.incremental&quot;, &quot;true&quot;)&#10;    arg(&quot;room.expandProjection&quot;, &quot;true&quot;)&#10;}&#10;&#10;dependencies {&#10;    // AndroidX Core&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;&#10;    // Compose&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-runtime-compose:2.7.0&quot;)&#10;    implementation(&quot;androidx.compose.runtime:runtime-livedata&quot;)&#10;&#10;    // Hilt&#10;    implementation(libs.hilt.android)&#10;    ksp(libs.hilt.compiler)&#10;    implementation(libs.androidx.hilt.navigation.compose)&#10;&#10;    // Room&#10;    implementation(&quot;androidx.room:room-runtime:2.6.1&quot;)&#10;    ksp(&quot;androidx.room:room-compiler:2.6.1&quot;)&#10;    implementation(&quot;androidx.room:room-ktx:2.6.1&quot;)&#10;&#10;    // Retrofit &amp; Network&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-moshi:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;)&#10;    implementation(&quot;com.squareup.moshi:moshi-kotlin:1.15.0&quot;)&#10;    ksp(&quot;com.squareup.moshi:moshi-kotlin-codegen:1.15.0&quot;)&#10;&#10;    // WorkManager&#10;    implementation(&quot;androidx.work:work-runtime-ktx:2.9.0&quot;)&#10;    implementation(&quot;androidx.hilt:hilt-work:1.1.0&quot;)&#10;    ksp(&quot;androidx.hilt:hilt-compiler:1.1.0&quot;) // Uncomment and fix this line&#10;&#10;&#10;    // Coroutines&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-play-services:1.7.3&quot;)&#10;&#10;    // Testing&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;&#10;    // Porcupine Wake Word Engine (Free tier)&#10;    implementation(&quot;ai.picovoice:porcupine-android:3.0.1&quot;)&#10;&#10;    // Additional audio processing&#10;    implementation(&quot;com.github.wendykierp:JTransforms:3.1&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/audio/SpeechToTextManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/audio/SpeechToTextManager.kt" />
              <option name="updatedContent" value="package com.example.diaensho.audio&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.speech.RecognitionListener&#10;import android.speech.RecognizerIntent&#10;import android.speech.SpeechRecognizer&#10;import android.util.Log&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import java.util.*&#10;&#10;@Singleton&#10;class SpeechToTextManager @Inject constructor(&#10;    private val context: Context&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;SpeechToTextManager&quot;&#10;        private const val RECOGNITION_TIMEOUT_MS = 30000L // 30 seconds&#10;        private const val SILENCE_TIMEOUT_MS = 5000L // 5 seconds of silence&#10;        private const val MAX_RETRY_ATTEMPTS = 3&#10;    }&#10;&#10;    private var speechRecognizer: SpeechRecognizer? = null&#10;    private var isListening = false&#10;    private var currentRetryCount = 0&#10;    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Main)&#10;    private var recognitionTimeoutJob: Job? = null&#10;    private var silenceTimeoutJob: Job? = null&#10;&#10;    private val _recognitionState = MutableStateFlow(RecognitionState.IDLE)&#10;    val recognitionState: StateFlow&lt;RecognitionState&gt; = _recognitionState&#10;&#10;    private val _partialResult = MutableStateFlow(&quot;&quot;)&#10;    val partialResult: StateFlow&lt;String&gt; = _partialResult&#10;&#10;    private val _finalResult = MutableStateFlow(&quot;&quot;)&#10;    val finalResult: StateFlow&lt;String&gt; = _finalResult&#10;&#10;    private val _confidence = MutableStateFlow(0f)&#10;    val confidence: StateFlow&lt;Float&gt; = _confidence&#10;&#10;    enum class RecognitionState {&#10;        IDLE, INITIALIZING, LISTENING, PROCESSING, ERROR, COMPLETED&#10;    }&#10;&#10;    data class RecognitionResult(&#10;        val text: String,&#10;        val confidence: Float,&#10;        val isPartial: Boolean = false&#10;    )&#10;&#10;    fun startListening(&#10;        onResult: (RecognitionResult) -&gt; Unit,&#10;        onError: (String) -&gt; Unit,&#10;        onComplete: () -&gt; Unit,&#10;        preferOffline: Boolean = false,&#10;        maxResults: Int = 5&#10;    ): Boolean {&#10;        if (isListening) {&#10;            Log.w(TAG, &quot;Already listening&quot;)&#10;            return false&#10;        }&#10;&#10;        if (!SpeechRecognizer.isRecognitionAvailable(context)) {&#10;            Log.e(TAG, &quot;Speech recognition not available&quot;)&#10;            onError(&quot;Speech recognition not available&quot;)&#10;            return false&#10;        }&#10;&#10;        return try {&#10;            _recognitionState.value = RecognitionState.INITIALIZING&#10;            _partialResult.value = &quot;&quot;&#10;            _finalResult.value = &quot;&quot;&#10;            _confidence.value = 0f&#10;&#10;            // Create and configure speech recognizer&#10;            speechRecognizer = SpeechRecognizer.createSpeechRecognizer(context)&#10;            &#10;            if (speechRecognizer == null) {&#10;                Log.e(TAG, &quot;Failed to create SpeechRecognizer&quot;)&#10;                onError(&quot;Failed to initialize speech recognition&quot;)&#10;                return false&#10;            }&#10;&#10;            val recognitionIntent = createRecognitionIntent(preferOffline, maxResults)&#10;            &#10;            speechRecognizer?.setRecognitionListener(object : RecognitionListener {&#10;                override fun onReadyForSpeech(params: Bundle?) {&#10;                    Log.d(TAG, &quot;Ready for speech&quot;)&#10;                    _recognitionState.value = RecognitionState.LISTENING&#10;                    startRecognitionTimeout(onError, onComplete)&#10;                    currentRetryCount = 0&#10;                }&#10;&#10;                override fun onBeginningOfSpeech() {&#10;                    Log.d(TAG, &quot;Beginning of speech detected&quot;)&#10;                    cancelSilenceTimeout()&#10;                    _recognitionState.value = RecognitionState.LISTENING&#10;                }&#10;&#10;                override fun onRmsChanged(rmsdB: Float) {&#10;                    // Normalize RMS to 0-1 range for UI feedback&#10;                    val normalizedLevel = (rmsdB + 40f) / 60f // Typical range is -40 to 20 dB&#10;                    _confidence.value = normalizedLevel.coerceIn(0f, 1f)&#10;                }&#10;&#10;                override fun onBufferReceived(buffer: ByteArray?) {&#10;                    // Audio buffer received - can be used for additional processing&#10;                }&#10;&#10;                override fun onEndOfSpeech() {&#10;                    Log.d(TAG, &quot;End of speech&quot;)&#10;                    _recognitionState.value = RecognitionState.PROCESSING&#10;                    startSilenceTimeout(onError, onComplete)&#10;                }&#10;&#10;                override fun onError(error: Int) {&#10;                    isListening = false&#10;                    cancelTimeouts()&#10;                    &#10;                    val errorMessage = when (error) {&#10;                        SpeechRecognizer.ERROR_AUDIO -&gt; &quot;Audio recording error&quot;&#10;                        SpeechRecognizer.ERROR_CLIENT -&gt; &quot;Client error&quot;&#10;                        SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS -&gt; &quot;Insufficient permissions&quot;&#10;                        SpeechRecognizer.ERROR_NETWORK -&gt; &quot;Network error&quot;&#10;                        SpeechRecognizer.ERROR_NETWORK_TIMEOUT -&gt; &quot;Network timeout&quot;&#10;                        SpeechRecognizer.ERROR_NO_MATCH -&gt; &quot;No speech detected&quot;&#10;                        SpeechRecognizer.ERROR_RECOGNIZER_BUSY -&gt; &quot;Recognizer busy&quot;&#10;                        SpeechRecognizer.ERROR_SERVER -&gt; &quot;Server error&quot;&#10;                        SpeechRecognizer.ERROR_SPEECH_TIMEOUT -&gt; &quot;Speech timeout&quot;&#10;                        else -&gt; &quot;Unknown error: $error&quot;&#10;                    }&#10;                    &#10;                    Log.e(TAG, &quot;Speech recognition error: $errorMessage&quot;)&#10;                    &#10;                    // Retry logic for certain errors&#10;                    if (shouldRetry(error) &amp;&amp; currentRetryCount &lt; MAX_RETRY_ATTEMPTS) {&#10;                        currentRetryCount++&#10;                        Log.i(TAG, &quot;Retrying recognition (attempt $currentRetryCount)&quot;)&#10;                        &#10;                        scope.launch {&#10;                            delay(1000) // Wait before retry&#10;                            if (!startListening(onResult, onError, onComplete, preferOffline, maxResults)) {&#10;                                _recognitionState.value = RecognitionState.ERROR&#10;                                onError(errorMessage)&#10;                            }&#10;                        }&#10;                    } else {&#10;                        _recognitionState.value = RecognitionState.ERROR&#10;                        onError(errorMessage)&#10;                    }&#10;                }&#10;&#10;                override fun onResults(results: Bundle?) {&#10;                    isListening = false&#10;                    cancelTimeouts()&#10;                    &#10;                    val matches = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)&#10;                    val confidenceScores = results?.getFloatArray(SpeechRecognizer.CONFIDENCE_SCORES)&#10;                    &#10;                    if (matches != null &amp;&amp; matches.isNotEmpty()) {&#10;                        val bestMatch = matches[0]&#10;                        val confidence = confidenceScores?.getOrNull(0) ?: 0f&#10;                        &#10;                        Log.d(TAG, &quot;Final result: $bestMatch (confidence: $confidence)&quot;)&#10;                        &#10;                        _finalResult.value = bestMatch&#10;                        _confidence.value = confidence&#10;                        _recognitionState.value = RecognitionState.COMPLETED&#10;                        &#10;                        onResult(RecognitionResult(bestMatch, confidence, isPartial = false))&#10;                        onComplete()&#10;                    } else {&#10;                        Log.w(TAG, &quot;No results received&quot;)&#10;                        _recognitionState.value = RecognitionState.ERROR&#10;                        onError(&quot;No speech detected&quot;)&#10;                    }&#10;                }&#10;&#10;                override fun onPartialResults(partialResults: Bundle?) {&#10;                    val matches = partialResults?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)&#10;                    val partial = matches?.firstOrNull() ?: &quot;&quot;&#10;                    &#10;                    if (partial.isNotEmpty()) {&#10;                        Log.d(TAG, &quot;Partial result: $partial&quot;)&#10;                        _partialResult.value = partial&#10;                        onResult(RecognitionResult(partial, 0f, isPartial = true))&#10;                        &#10;                        // Reset silence timeout as we're getting partial results&#10;                        resetSilenceTimeout(onError, onComplete)&#10;                    }&#10;                }&#10;&#10;                override fun onEvent(eventType: Int, params: Bundle?) {&#10;                    Log.d(TAG, &quot;Recognition event: $eventType&quot;)&#10;                }&#10;            })&#10;&#10;            isListening = true&#10;            speechRecognizer?.startListening(recognitionIntent)&#10;            Log.i(TAG, &quot;Speech recognition started&quot;)&#10;            true&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to start speech recognition&quot;, e)&#10;            _recognitionState.value = RecognitionState.ERROR&#10;            onError(&quot;Failed to start speech recognition: ${e.message}&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun createRecognitionIntent(preferOffline: Boolean, maxResults: Int): Intent {&#10;        return Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {&#10;            putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)&#10;            putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.getDefault())&#10;            putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS, true)&#10;            putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, maxResults)&#10;            putExtra(RecognizerIntent.EXTRA_PREFER_OFFLINE, preferOffline)&#10;            putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE, context.packageName)&#10;            &#10;            // Enhanced audio settings for better recognition&#10;            putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_COMPLETE_SILENCE_LENGTH_MILLIS, SILENCE_TIMEOUT_MS)&#10;            putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_POSSIBLY_COMPLETE_SILENCE_LENGTH_MILLIS, SILENCE_TIMEOUT_MS / 2)&#10;            putExtra(RecognizerIntent.EXTRA_SPEECH_INPUT_MINIMUM_LENGTH_MILLIS, 1000)&#10;            &#10;            // Request confidence scores&#10;            putExtra(RecognizerIntent.EXTRA_CONFIDENCE_SCORES, true)&#10;        }&#10;    }&#10;&#10;    private fun shouldRetry(error: Int): Boolean {&#10;        return when (error) {&#10;            SpeechRecognizer.ERROR_NETWORK,&#10;            SpeechRecognizer.ERROR_NETWORK_TIMEOUT,&#10;            SpeechRecognizer.ERROR_SERVER,&#10;            SpeechRecognizer.ERROR_RECOGNIZER_BUSY -&gt; true&#10;            else -&gt; false&#10;        }&#10;    }&#10;&#10;    private fun startRecognitionTimeout(onError: (String) -&gt; Unit, onComplete: () -&gt; Unit) {&#10;        recognitionTimeoutJob = scope.launch {&#10;            delay(RECOGNITION_TIMEOUT_MS)&#10;            if (isListening) {&#10;                Log.w(TAG, &quot;Recognition timeout&quot;)&#10;                stopListening()&#10;                _recognitionState.value = RecognitionState.ERROR&#10;                onError(&quot;Recognition timed out&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startSilenceTimeout(onError: (String) -&gt; Unit, onComplete: () -&gt; Unit) {&#10;        silenceTimeoutJob = scope.launch {&#10;            delay(SILENCE_TIMEOUT_MS)&#10;            if (isListening) {&#10;                Log.i(TAG, &quot;Silence timeout - completing recognition&quot;)&#10;                stopListening()&#10;                if (_partialResult.value.isNotEmpty()) {&#10;                    _finalResult.value = _partialResult.value&#10;                    _recognitionState.value = RecognitionState.COMPLETED&#10;                    onComplete()&#10;                } else {&#10;                    _recognitionState.value = RecognitionState.ERROR&#10;                    onError(&quot;No speech detected after silence&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun resetSilenceTimeout(onError: (String) -&gt; Unit, onComplete: () -&gt; Unit) {&#10;        cancelSilenceTimeout()&#10;        startSilenceTimeout(onError, onComplete)&#10;    }&#10;&#10;    private fun cancelTimeouts() {&#10;        recognitionTimeoutJob?.cancel()&#10;        silenceTimeoutJob?.cancel()&#10;    }&#10;&#10;    private fun cancelSilenceTimeout() {&#10;        silenceTimeoutJob?.cancel()&#10;    }&#10;&#10;    fun stopListening() {&#10;        if (!isListening) return&#10;&#10;        isListening = false&#10;        cancelTimeouts()&#10;        &#10;        try {&#10;            speechRecognizer?.cancel()&#10;            speechRecognizer?.destroy()&#10;            speechRecognizer = null&#10;            &#10;            if (_recognitionState.value != RecognitionState.COMPLETED) {&#10;                _recognitionState.value = RecognitionState.IDLE&#10;            }&#10;            &#10;            Log.i(TAG, &quot;Speech recognition stopped&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error stopping speech recognition&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun release() {&#10;        stopListening()&#10;        scope.cancel()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/audio/WakeWordDetector.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/audio/WakeWordDetector.kt" />
              <option name="originalContent" value="package com.example.diaensho.audio&#10;&#10;import ai.picovoice.porcupine.*&#10;import android.Manifest&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class WakeWordDetector @Inject constructor(&#10;    private val context: Context,&#10;    private val audioManager: AudioManager&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;WakeWordDetector&quot;&#10;        // Using built-in keywords that sound similar to &quot;dear diary&quot;&#10;        private val BUILT_IN_KEYWORDS = arrayOf(&#10;            Porcupine.BuiltInKeyword.COMPUTER,&#10;            Porcupine.BuiltInKeyword.ALEXA&#10;        )&#10;        private const val ACCESS_KEY = &quot;Y531/lrxl6J8CcOti3Azsdeev6nobt1thBsVHAV12UOjHDBNckficA==&quot; // Free tier - leave empty for built-in keywords&#10;    }&#10;&#10;    private var porcupine: Porcupine? = null&#10;    private var isListening = false&#10;    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)&#10;    private var audioBuffer = mutableListOf&lt;Short&gt;()&#10;&#10;    private val _detectionState = MutableStateFlow(DetectionState.IDLE)&#10;    val detectionState: StateFlow&lt;DetectionState&gt; = _detectionState&#10;&#10;    private val _lastDetection = MutableStateFlow&lt;String?&gt;(null)&#10;    val lastDetection: StateFlow&lt;String?&gt; = _lastDetection&#10;&#10;    enum class DetectionState {&#10;        IDLE, INITIALIZING, LISTENING, ERROR&#10;    }&#10;&#10;    @RequiresPermission(Manifest.permission.RECORD_AUDIO)&#10;    fun startListening(onWakeWordDetected: (String) -&gt; Unit): Boolean {&#10;        if (isListening) {&#10;            Log.w(TAG, &quot;Already listening for wake words&quot;)&#10;            return false&#10;        }&#10;&#10;        return try {&#10;            _detectionState.value = DetectionState.INITIALIZING&#10;&#10;            // Initialize Porcupine with built-in keywords (free tier)&#10;            val porcupineBuilder = Porcupine.Builder()&#10;                .setAccessKey(ACCESS_KEY) // Empty for free tier with built-in keywords&#10;                .setKeywords(BUILT_IN_KEYWORDS)&#10;&#10;            porcupine = porcupineBuilder.build(context)&#10;&#10;            val frameLength = porcupine?.frameLength ?: 0&#10;            if (frameLength &lt;= 0) {&#10;                Log.e(TAG, &quot;Invalid frame length: $frameLength&quot;)&#10;                _detectionState.value = DetectionState.ERROR&#10;                return false&#10;            }&#10;&#10;            Log.i(TAG, &quot;Porcupine initialized with frame length: $frameLength&quot;)&#10;&#10;            // Start audio recording&#10;            val audioStarted = audioManager.startRecording { audioData -&gt;&#10;                processAudioForWakeWord(audioData, frameLength, onWakeWordDetected)&#10;            }&#10;&#10;            if (!audioStarted) {&#10;                Log.e(TAG, &quot;Failed to start audio recording&quot;)&#10;                _detectionState.value = DetectionState.ERROR&#10;                return false&#10;            }&#10;&#10;            isListening = true&#10;            _detectionState.value = DetectionState.LISTENING&#10;            Log.i(TAG, &quot;Wake word detection started successfully&quot;)&#10;            true&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to start wake word detection&quot;, e)&#10;            _detectionState.value = DetectionState.ERROR&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun processAudioForWakeWord(&#10;        audioData: ShortArray,&#10;        frameLength: Int,&#10;        onWakeWordDetected: (String) -&gt; Unit&#10;    ) {&#10;        try {&#10;            // Add new audio data to buffer&#10;            audioBuffer.addAll(audioData.toList())&#10;&#10;            // Process audio in chunks of the required frame length&#10;            while (audioBuffer.size &gt;= frameLength) {&#10;                val frame = audioBuffer.take(frameLength).toShortArray()&#10;                audioBuffer = audioBuffer.drop(frameLength).toMutableList()&#10;&#10;                val keywordIndex = porcupine?.process(frame) ?: -1&#10;&#10;                if (keywordIndex &gt;= 0 &amp;&amp; keywordIndex &lt; BUILT_IN_KEYWORDS.size) {&#10;                    val detectedKeyword = when (BUILT_IN_KEYWORDS[keywordIndex]) {&#10;                        Porcupine.BuiltInKeyword.COMPUTER -&gt; &quot;computer&quot;&#10;                        Porcupine.BuiltInKeyword.ALEXA -&gt; &quot;alexa&quot;&#10;                        else -&gt; &quot;unknown&quot;&#10;                    }&#10;&#10;                    Log.i(TAG, &quot;Wake word detected: $detectedKeyword&quot;)&#10;                    _lastDetection.value = detectedKeyword&#10;&#10;                    // For our app, we'll treat any built-in keyword as &quot;dear diary&quot;&#10;                    scope.launch(Dispatchers.Main) {&#10;                        onWakeWordDetected(&quot;dear diary&quot;)&#10;                    }&#10;                    break&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error processing audio for wake word&quot;, e)&#10;            _detectionState.value = DetectionState.ERROR&#10;        }&#10;    }&#10;&#10;    fun stopListening() {&#10;        if (!isListening) return&#10;&#10;        isListening = false&#10;        audioManager.stopRecording()&#10;        audioBuffer.clear()&#10;&#10;        try {&#10;            porcupine?.delete()&#10;            porcupine = null&#10;            _detectionState.value = DetectionState.IDLE&#10;            Log.i(TAG, &quot;Wake word detection stopped&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error stopping wake word detection&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun release() {&#10;        stopListening()&#10;        scope.cancel()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.audio&#10;&#10;import ai.picovoice.porcupine.*&#10;import android.Manifest&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import com.example.diaensho.BuildConfig&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class WakeWordDetector @Inject constructor(&#10;    private val context: Context,&#10;    private val audioManager: AudioManager&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;WakeWordDetector&quot;&#10;        // Using built-in keywords that sound similar to &quot;dear diary&quot;&#10;        private val BUILT_IN_KEYWORDS = arrayOf(&#10;            Porcupine.BuiltInKeyword.COMPUTER,&#10;            Porcupine.BuiltInKeyword.ALEXA&#10;        )&#10;        // Access key is now loaded from BuildConfig (secure)&#10;    }&#10;&#10;    private var porcupine: Porcupine? = null&#10;    private var isListening = false&#10;    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)&#10;    private var audioBuffer = mutableListOf&lt;Short&gt;()&#10;&#10;    private val _detectionState = MutableStateFlow(DetectionState.IDLE)&#10;    val detectionState: StateFlow&lt;DetectionState&gt; = _detectionState&#10;&#10;    private val _lastDetection = MutableStateFlow&lt;String?&gt;(null)&#10;    val lastDetection: StateFlow&lt;String?&gt; = _lastDetection&#10;&#10;    enum class DetectionState {&#10;        IDLE, INITIALIZING, LISTENING, ERROR&#10;    }&#10;&#10;    @RequiresPermission(Manifest.permission.RECORD_AUDIO)&#10;    fun startListening(onWakeWordDetected: (String) -&gt; Unit): Boolean {&#10;        if (isListening) {&#10;            Log.w(TAG, &quot;Already listening for wake words&quot;)&#10;            return false&#10;        }&#10;&#10;        return try {&#10;            _detectionState.value = DetectionState.INITIALIZING&#10;&#10;            // Initialize Porcupine with built-in keywords (free tier)&#10;            val porcupineBuilder = Porcupine.Builder()&#10;                .setAccessKey(BuildConfig.PORCUPINE_ACCESS_KEY) // Empty for free tier with built-in keywords&#10;                .setKeywords(BUILT_IN_KEYWORDS)&#10;&#10;            porcupine = porcupineBuilder.build(context)&#10;&#10;            val frameLength = porcupine?.frameLength ?: 0&#10;            if (frameLength &lt;= 0) {&#10;                Log.e(TAG, &quot;Invalid frame length: $frameLength&quot;)&#10;                _detectionState.value = DetectionState.ERROR&#10;                return false&#10;            }&#10;&#10;            Log.i(TAG, &quot;Porcupine initialized with frame length: $frameLength&quot;)&#10;&#10;            // Start audio recording&#10;            val audioStarted = audioManager.startRecording { audioData -&gt;&#10;                processAudioForWakeWord(audioData, frameLength, onWakeWordDetected)&#10;            }&#10;&#10;            if (!audioStarted) {&#10;                Log.e(TAG, &quot;Failed to start audio recording&quot;)&#10;                _detectionState.value = DetectionState.ERROR&#10;                return false&#10;            }&#10;&#10;            isListening = true&#10;            _detectionState.value = DetectionState.LISTENING&#10;            Log.i(TAG, &quot;Wake word detection started successfully&quot;)&#10;            true&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to start wake word detection&quot;, e)&#10;            _detectionState.value = DetectionState.ERROR&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun processAudioForWakeWord(&#10;        audioData: ShortArray,&#10;        frameLength: Int,&#10;        onWakeWordDetected: (String) -&gt; Unit&#10;    ) {&#10;        try {&#10;            // Add new audio data to buffer&#10;            audioBuffer.addAll(audioData.toList())&#10;&#10;            // Process audio in chunks of the required frame length&#10;            while (audioBuffer.size &gt;= frameLength) {&#10;                val frame = audioBuffer.take(frameLength).toShortArray()&#10;                audioBuffer = audioBuffer.drop(frameLength).toMutableList()&#10;&#10;                val keywordIndex = porcupine?.process(frame) ?: -1&#10;&#10;                if (keywordIndex &gt;= 0 &amp;&amp; keywordIndex &lt; BUILT_IN_KEYWORDS.size) {&#10;                    val detectedKeyword = when (BUILT_IN_KEYWORDS[keywordIndex]) {&#10;                        Porcupine.BuiltInKeyword.COMPUTER -&gt; &quot;computer&quot;&#10;                        Porcupine.BuiltInKeyword.ALEXA -&gt; &quot;alexa&quot;&#10;                        else -&gt; &quot;unknown&quot;&#10;                    }&#10;&#10;                    Log.i(TAG, &quot;Wake word detected: $detectedKeyword&quot;)&#10;                    _lastDetection.value = detectedKeyword&#10;&#10;                    // For our app, we'll treat any built-in keyword as &quot;dear diary&quot;&#10;                    scope.launch(Dispatchers.Main) {&#10;                        onWakeWordDetected(&quot;dear diary&quot;)&#10;                    }&#10;                    break&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error processing audio for wake word&quot;, e)&#10;            _detectionState.value = DetectionState.ERROR&#10;        }&#10;    }&#10;&#10;    fun stopListening() {&#10;        if (!isListening) return&#10;&#10;        isListening = false&#10;        audioManager.stopRecording()&#10;        audioBuffer.clear()&#10;&#10;        try {&#10;            porcupine?.delete()&#10;            porcupine = null&#10;            _detectionState.value = DetectionState.IDLE&#10;            Log.i(TAG, &quot;Wake word detection stopped&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error stopping wake word detection&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun release() {&#10;        stopListening()&#10;        scope.cancel()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/ui/screen/OnboardingScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/ui/screen/OnboardingScreen.kt" />
              <option name="originalContent" value="package com.example.diaensho.ui.screen&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.diaensho.util.PowerManagerHelper&#10;import com.example.diaensho.viewmodel.OnboardingViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;&#10;@Composable&#10;fun OnboardingScreen(&#10;    onboardingViewModel: OnboardingViewModel = viewModel(),&#10;    onPermissionsGranted: () -&gt; Unit,&#10;    onRequestMicPermission: () -&gt; Unit,&#10;    onRequestUsageStatsPermission: () -&gt; Unit&#10;) {&#10;    val uiState by onboardingViewModel.uiState.collectAsStateWithLifecycle()&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            text = &quot;Welcome to Cogniscribe!&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        Text(&#10;            text = &quot;Please grant the following permissions to enable voice diary entries:&quot;,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;        // Microphone Permission&#10;        PermissionButton(&#10;            text = if (uiState.microphonePermissionGranted) &quot;✓ Microphone Granted&quot; else &quot;Grant Microphone Permission&quot;,&#10;            onClick = onRequestMicPermission,&#10;            enabled = !uiState.microphonePermissionGranted,&#10;            description = &quot;Required for voice recognition&quot;&#10;        )&#10;&#10;        // Usage Stats Permission&#10;        PermissionButton(&#10;            text = if (uiState.usageStatsPermissionGranted) &quot;✓ Usage Stats Granted&quot; else &quot;Grant Usage Stats Permission&quot;,&#10;            onClick = onRequestUsageStatsPermission,&#10;            enabled = !uiState.usageStatsPermissionGranted,&#10;            description = &quot;Required for app usage tracking&quot;&#10;        )&#10;&#10;        // Battery Optimization Permission&#10;        PermissionButton(&#10;            text = if (uiState.batteryOptimizationDisabled) &quot;✓ Battery Optimization Disabled&quot; else &quot;Disable Battery Optimization&quot;,&#10;            onClick = {&#10;                context.startActivity(onboardingViewModel.getBatteryOptimizationIntent())&#10;            },&#10;            enabled = !uiState.batteryOptimizationDisabled,&#10;            description = &quot;Required for reliable voice detection&quot;&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        Button(&#10;            onClick = onPermissionsGranted,&#10;            enabled = uiState.allPermissionsGranted,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&quot;Continue&quot;)&#10;        }&#10;&#10;        if (!uiState.allPermissionsGranted) {&#10;            Text(&#10;                text = &quot;Please grant all permissions to continue&quot;,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = MaterialTheme.colorScheme.error&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PermissionButton(&#10;    text: String,&#10;    onClick: () -&gt; Unit,&#10;    enabled: Boolean,&#10;    description: String&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Button(&#10;            onClick = onClick,&#10;            enabled = enabled,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(text)&#10;        }&#10;        if (enabled) {&#10;            Text(&#10;                text = description,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.ui.screen&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.diaensho.viewmodel.OnboardingViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;&#10;@Composable&#10;fun OnboardingScreen(&#10;    onboardingViewModel: OnboardingViewModel = viewModel(),&#10;    onPermissionsGranted: () -&gt; Unit,&#10;    onRequestMicPermission: () -&gt; Unit,&#10;    onRequestUsageStatsPermission: () -&gt; Unit&#10;) {&#10;    val uiState by onboardingViewModel.uiState.collectAsStateWithLifecycle()&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            text = &quot;Welcome to Cogniscribe!&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        Text(&#10;            text = &quot;Please grant the following permissions to enable voice diary entries:&quot;,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            textAlign = TextAlign.Center&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;        // Microphone Permission&#10;        PermissionButton(&#10;            text = if (uiState.microphonePermissionGranted) &quot;✓ Microphone Granted&quot; else &quot;Grant Microphone Permission&quot;,&#10;            onClick = onRequestMicPermission,&#10;            enabled = !uiState.microphonePermissionGranted,&#10;            description = &quot;Required for voice recognition&quot;&#10;        )&#10;&#10;        // Usage Stats Permission&#10;        PermissionButton(&#10;            text = if (uiState.usageStatsPermissionGranted) &quot;✓ Usage Stats Granted&quot; else &quot;Grant Usage Stats Permission&quot;,&#10;            onClick = onRequestUsageStatsPermission,&#10;            enabled = !uiState.usageStatsPermissionGranted,&#10;            description = &quot;Required for app usage tracking&quot;&#10;        )&#10;&#10;        // Battery Optimization Permission&#10;        PermissionButton(&#10;            text = if (uiState.batteryOptimizationDisabled) &quot;✓ Battery Optimization Disabled&quot; else &quot;Disable Battery Optimization&quot;,&#10;            onClick = {&#10;                context.startActivity(onboardingViewModel.getBatteryOptimizationIntent())&#10;            },&#10;            enabled = !uiState.batteryOptimizationDisabled,&#10;            description = &quot;Required for reliable voice detection&quot;&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(32.dp))&#10;&#10;        Button(&#10;            onClick = onPermissionsGranted,&#10;            enabled = uiState.allPermissionsGranted,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&quot;Continue&quot;)&#10;        }&#10;&#10;        if (!uiState.allPermissionsGranted) {&#10;            Text(&#10;                text = &quot;Please grant all permissions to continue&quot;,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = MaterialTheme.colorScheme.error&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PermissionButton(&#10;    text: String,&#10;    onClick: () -&gt; Unit,&#10;    enabled: Boolean,&#10;    description: String&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Button(&#10;            onClick = onClick,&#10;            enabled = enabled,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(text)&#10;        }&#10;        if (enabled) {&#10;            Text(&#10;                text = description,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/viewmodel/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/viewmodel/HomeViewModel.kt" />
              <option name="originalContent" value="package com.example.diaensho.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.diaensho.data.db.entity.DiaryEntryEntity&#10;import com.example.diaensho.data.db.entity.AppUsageStatEntity&#10;import com.example.diaensho.data.repository.MainRepository&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val repository: MainRepository&#10;) : ViewModel() {&#10;    private val _entries = MutableStateFlow&lt;List&lt;DiaryEntryEntity&gt;&gt;(emptyList())&#10;    val entries: StateFlow&lt;List&lt;DiaryEntryEntity&gt;&gt; = _entries.asStateFlow()&#10;&#10;    private val _appUsageStats = MutableStateFlow&lt;List&lt;AppUsageStatEntity&gt;&gt;(emptyList())&#10;    val appUsageStats: StateFlow&lt;List&lt;AppUsageStatEntity&gt;&gt; = _appUsageStats.asStateFlow()&#10;&#10;    private var currentDate: LocalDate = LocalDate.now()&#10;&#10;    init {&#10;        loadDataForDate(currentDate)&#10;    }&#10;&#10;    fun loadDataForDate(date: LocalDate) {&#10;        currentDate = date&#10;        viewModelScope.launch {&#10;            // Load diary entries&#10;            repository.getDiaryEntriesForDate(date).collect {&#10;                _entries.value = it&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            // Load app usage stats&#10;            repository.getAppUsageStatsForDate(date).collect {&#10;                _appUsageStats.value = it.sortedByDescending { stat -&gt; stat.totalTimeInForeground }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.viewmodel&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.diaensho.data.db.entity.DiaryEntryEntity&#10;import com.example.diaensho.data.db.entity.AppUsageStatEntity&#10;import com.example.diaensho.data.repository.MainRepository&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val repository: MainRepository&#10;) : ViewModel() {&#10;    private val _entries = MutableStateFlow&lt;List&lt;DiaryEntryEntity&gt;&gt;(emptyList())&#10;    val entries: StateFlow&lt;List&lt;DiaryEntryEntity&gt;&gt; = _entries.asStateFlow()&#10;&#10;    private val _appUsageStats = MutableStateFlow&lt;List&lt;AppUsageStatEntity&gt;&gt;(emptyList())&#10;    val appUsageStats: StateFlow&lt;List&lt;AppUsageStatEntity&gt;&gt; = _appUsageStats.asStateFlow()&#10;&#10;    private var currentDate: LocalDate = LocalDate.now()&#10;&#10;    init {&#10;        Log.d(&quot;HomeViewModel&quot;, &quot;Initializing HomeViewModel for date: $currentDate&quot;)&#10;        loadDataForDate(currentDate)&#10;    }&#10;&#10;    fun loadDataForDate(date: LocalDate) {&#10;        Log.d(&quot;HomeViewModel&quot;, &quot;Loading data for date: $date&quot;)&#10;        currentDate = date&#10;&#10;        viewModelScope.launch {&#10;            // Load diary entries&#10;            Log.d(&quot;HomeViewModel&quot;, &quot;Starting to load diary entries for: $date&quot;)&#10;            repository.getDiaryEntriesForDate(date).collect { entriesList -&gt;&#10;                Log.d(&quot;HomeViewModel&quot;, &quot;Received ${entriesList.size} diary entries for $date&quot;)&#10;                entriesList.forEach { entry -&gt;&#10;                    Log.v(&quot;HomeViewModel&quot;, &quot;Entry ID: ${entry.id}, Text: '${entry.text.take(50)}...', Time: ${entry.timestamp}&quot;)&#10;                }&#10;                _entries.value = entriesList&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            // Load app usage stats&#10;            Log.d(&quot;HomeViewModel&quot;, &quot;Starting to load app usage stats for: $date&quot;)&#10;            repository.getAppUsageStatsForDate(date).collect { statsList -&gt;&#10;                Log.d(&quot;HomeViewModel&quot;, &quot;Received ${statsList.size} app usage stats for $date&quot;)&#10;                _appUsageStats.value = statsList.sortedByDescending { stat -&gt; stat.totalTimeInForeground }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/local.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/local.properties" />
              <option name="originalContent" value="## This file is automatically generated by Android Studio.&#10;# Do not modify this file -- YOUR CHANGES WILL BE ERASED!&#10;#&#10;# This file should *NOT* be checked into Version Control Systems,&#10;# as it contains information specific to your local configuration.&#10;#&#10;# Location of the SDK. This is only used by Gradle.&#10;# For customization when using a Version Control System, please read the&#10;# header note.&#10;sdk.dir=/home/mobotronst/Android/Sdk" />
              <option name="updatedContent" value="## This file is automatically generated by Android Studio.&#10;# Do not modify this file -- YOUR CHANGES WILL BE ERASED!&#10;#&#10;# This file should *NOT* be checked into Version Control Systems,&#10;# as it contains information specific to your local configuration.&#10;#&#10;# Location of the SDK. This is only used by Gradle.&#10;# For customization when using a Version Control System, please read the&#10;# header note.&#10;sdk.dir=/home/mobotronst/Android/Sdk&#10;&#10;# Porcupine Access Key (keep this secret)&#10;porcupine.access.key=Y531/lrxl6J8CcOti3Azsdeev6nobt1thBsVHAV12UOjHDBNckficA==" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/local.properties.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/local.properties.example" />
              <option name="updatedContent" value="## This file is automatically generated by Android Studio.&#10;# Do not modify this file -- YOUR CHANGES WILL BE ERASED!&#10;#&#10;# This file should *NOT* be checked into Version Control Systems,&#10;# as it contains information specific to your local configuration.&#10;#&#10;# Location of the SDK. This is only used by Gradle.&#10;# For customization when using a Version Control System, please read the&#10;# header note.&#10;sdk.dir=/path/to/your/Android/Sdk&#10;&#10;# Porcupine Access Key (keep this secret)&#10;# Get your free access key from: https://console.picovoice.ai/&#10;# Copy this file to local.properties and replace with your actual key&#10;porcupine.access.key=YOUR_PORCUPINE_ACCESS_KEY_HERE" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>