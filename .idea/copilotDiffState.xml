<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/MainActivity.kt" />
              <option name="originalContent" value="package com.example.diaensho&#10;&#10;import android.Manifest&#10;import android.app.AppOpsManager&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.diaensho.service.HotwordDetectionService&#10;import com.example.diaensho.ui.screen.*&#10;import com.example.diaensho.ui.theme.DiaenshoTheme&#10;import com.example.diaensho.viewmodel.AuthViewModel&#10;import com.example.diaensho.viewmodel.OnboardingViewModel&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import java.time.LocalDate&#10;&#10;@AndroidEntryPoint&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private val requestMicrophonePermission = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        onboardingViewModel?.setMicrophonePermission(isGranted)&#10;    }&#10;&#10;    private val requestUsageStatsPermission = registerForActivityResult(&#10;        ActivityResultContracts.StartActivityForResult()&#10;    ) {&#10;        onboardingViewModel?.setUsageStatsPermission(hasUsageStatsPermission())&#10;    }&#10;&#10;    private var onboardingViewModel: OnboardingViewModel? = null&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        setContent {&#10;            DiaenshoTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    MainApp()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    private fun MainApp() {&#10;        val navController = rememberNavController()&#10;        val authViewModel: AuthViewModel = viewModel()&#10;        val authUiState by authViewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;        var selectedDate by remember { mutableStateOf(LocalDate.now()) }&#10;&#10;        // Determine start destination based on auth state&#10;        val startDestination = when {&#10;            !authUiState.isSignedIn -&gt; &quot;signin&quot;&#10;            !authUiState.isOnboardingCompleted -&gt; &quot;onboarding&quot;&#10;            else -&gt; &quot;home&quot;&#10;        }&#10;&#10;        LaunchedEffect(authUiState.isSignedIn, authUiState.isOnboardingCompleted) {&#10;            when {&#10;                !authUiState.isSignedIn -&gt; {&#10;                    navController.navigate(&quot;signin&quot;) {&#10;                        popUpTo(0) { inclusive = true }&#10;                    }&#10;                }&#10;                authUiState.isSignedIn &amp;&amp; !authUiState.isOnboardingCompleted -&gt; {&#10;                    navController.navigate(&quot;onboarding&quot;) {&#10;                        popUpTo(0) { inclusive = true }&#10;                    }&#10;                }&#10;                authUiState.isSignedIn &amp;&amp; authUiState.isOnboardingCompleted -&gt; {&#10;                    navController.navigate(&quot;home&quot;) {&#10;                        popUpTo(0) { inclusive = true }&#10;                    }&#10;                    // Start the hotword service after successful auth and onboarding&#10;                    startHotwordService()&#10;                }&#10;            }&#10;        }&#10;&#10;        NavHost(&#10;            navController = navController,&#10;            startDestination = startDestination&#10;        ) {&#10;            // Authentication screens&#10;            composable(&quot;signin&quot;) {&#10;                SignInScreen(&#10;                    authViewModel = authViewModel,&#10;                    onSignInSuccess = {&#10;                        if (authUiState.isOnboardingCompleted) {&#10;                            navController.navigate(&quot;home&quot;) {&#10;                                popUpTo(&quot;signin&quot;) { inclusive = true }&#10;                            }&#10;                        } else {&#10;                            navController.navigate(&quot;onboarding&quot;) {&#10;                                popUpTo(&quot;signin&quot;) { inclusive = true }&#10;                            }&#10;                        }&#10;                    },&#10;                    onNavigateToSignUp = {&#10;                        navController.navigate(&quot;signup&quot;)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable(&quot;signup&quot;) {&#10;                SignUpScreen(&#10;                    authViewModel = authViewModel,&#10;                    onSignUpSuccess = {&#10;                        if (authUiState.isOnboardingCompleted) {&#10;                            navController.navigate(&quot;home&quot;) {&#10;                                popUpTo(&quot;signup&quot;) { inclusive = true }&#10;                            }&#10;                        } else {&#10;                            navController.navigate(&quot;onboarding&quot;) {&#10;                                popUpTo(&quot;signup&quot;) { inclusive = true }&#10;                            }&#10;                        }&#10;                    },&#10;                    onNavigateToSignIn = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Onboarding screen&#10;            composable(&quot;onboarding&quot;) {&#10;                val onboardingVM: OnboardingViewModel = viewModel()&#10;                onboardingViewModel = onboardingVM&#10;&#10;                // Check permissions on composition&#10;                LaunchedEffect(Unit) {&#10;                    onboardingVM.setMicrophonePermission(hasMicrophonePermission())&#10;                    onboardingVM.setUsageStatsPermission(hasUsageStatsPermission())&#10;                    onboardingVM.checkBatteryOptimization()&#10;                }&#10;&#10;                OnboardingScreen(&#10;                    onboardingViewModel = onboardingVM,&#10;                    onPermissionsGranted = {&#10;                        authViewModel.completeOnboarding()&#10;                        navController.navigate(&quot;home&quot;) {&#10;                            popUpTo(&quot;onboarding&quot;) { inclusive = true }&#10;                        }&#10;                    },&#10;                    onRequestMicPermission = { requestMicrophonePermission() },&#10;                    onRequestUsageStatsPermission = { requestUsageStatsPermission() }&#10;                )&#10;            }&#10;&#10;            // Main app screens&#10;            composable(&quot;home&quot;) {&#10;                HomeScreen(&#10;                    selectedDate = selectedDate,&#10;                    onDateChange = { selectedDate = it },&#10;                    onSearchClick = {&#10;                        navController.navigate(&quot;search&quot;)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable(&quot;search&quot;) {&#10;                SearchScreen(&#10;                    onBack = { navController.popBackStack() }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun requestMicrophonePermission() {&#10;        requestMicrophonePermission.launch(Manifest.permission.RECORD_AUDIO)&#10;    }&#10;&#10;    private fun requestUsageStatsPermission() {&#10;        val intent = Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS)&#10;        requestUsageStatsPermission.launch(intent)&#10;    }&#10;&#10;    private fun hasMicrophonePermission(): Boolean {&#10;        return ContextCompat.checkSelfPermission(&#10;            this,&#10;            Manifest.permission.RECORD_AUDIO&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;&#10;    private fun hasUsageStatsPermission(): Boolean {&#10;        val appOpsManager = getSystemService(Context.APP_OPS_SERVICE) as AppOpsManager&#10;        val mode = appOpsManager.checkOpNoThrow(&#10;            AppOpsManager.OPSTR_GET_USAGE_STATS,&#10;            android.os.Process.myUid(),&#10;            packageName&#10;        )&#10;        return mode == AppOpsManager.MODE_ALLOWED&#10;    }&#10;&#10;    private fun startHotwordService() {&#10;        if (hasMicrophonePermission()) {&#10;            val serviceIntent = Intent(this, HotwordDetectionService::class.java)&#10;            startForegroundService(serviceIntent)&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Update onboarding permissions when returning to the app&#10;        onboardingViewModel?.let { vm -&gt;&#10;            vm.setMicrophonePermission(hasMicrophonePermission())&#10;            vm.setUsageStatsPermission(hasUsageStatsPermission())&#10;            vm.checkBatteryOptimization()&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho&#10;&#10;import android.Manifest&#10;import android.app.AppOpsManager&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.provider.Settings&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.core.content.ContextCompat&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.diaensho.service.HotwordDetectionService&#10;import com.example.diaensho.ui.screen.*&#10;import com.example.diaensho.ui.theme.DiaenshoTheme&#10;import com.example.diaensho.viewmodel.AuthViewModel&#10;import com.example.diaensho.viewmodel.OnboardingViewModel&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import java.time.LocalDate&#10;&#10;@AndroidEntryPoint&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private val requestMicrophonePermission = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        onboardingViewModel?.setMicrophonePermission(isGranted)&#10;    }&#10;&#10;    private val requestUsageStatsPermission = registerForActivityResult(&#10;        ActivityResultContracts.StartActivityForResult()&#10;    ) {&#10;        onboardingViewModel?.setUsageStatsPermission(hasUsageStatsPermission())&#10;    }&#10;&#10;    private var onboardingViewModel: OnboardingViewModel? = null&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        setContent {&#10;            DiaenshoTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    MainApp()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    private fun MainApp() {&#10;        val navController = rememberNavController()&#10;        val authViewModel: AuthViewModel = hiltViewModel()&#10;        val authUiState by authViewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;        var selectedDate by remember { mutableStateOf(LocalDate.now()) }&#10;&#10;        // Determine start destination based on auth state&#10;        val startDestination = when {&#10;            !authUiState.isSignedIn -&gt; &quot;signin&quot;&#10;            !authUiState.isOnboardingCompleted -&gt; &quot;onboarding&quot;&#10;            else -&gt; &quot;home&quot;&#10;        }&#10;&#10;        LaunchedEffect(authUiState.isSignedIn, authUiState.isOnboardingCompleted) {&#10;            when {&#10;                !authUiState.isSignedIn -&gt; {&#10;                    navController.navigate(&quot;signin&quot;) {&#10;                        popUpTo(navController.graph.startDestinationId) {&#10;                            inclusive = true&#10;                        }&#10;                    }&#10;                }&#10;                !authUiState.isOnboardingCompleted -&gt; {&#10;                    navController.navigate(&quot;onboarding&quot;) {&#10;                        popUpTo(navController.graph.startDestinationId) {&#10;                            inclusive = true&#10;                        }&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    navController.navigate(&quot;home&quot;) {&#10;                        popUpTo(navController.graph.startDestinationId) {&#10;                            inclusive = true&#10;                        }&#10;                    }&#10;                    // Start the hotword detection service when fully authenticated and onboarded&#10;                    startHotwordService()&#10;                }&#10;            }&#10;        }&#10;&#10;        NavHost(&#10;            navController = navController,&#10;            startDestination = startDestination&#10;        ) {&#10;            composable(&quot;signin&quot;) {&#10;                SignInScreen(&#10;                    authViewModel = authViewModel,&#10;                    onSignInSuccess = {&#10;                        if (authUiState.isOnboardingCompleted) {&#10;                            navController.navigate(&quot;home&quot;) {&#10;                                popUpTo(&quot;signin&quot;) { inclusive = true }&#10;                            }&#10;                        } else {&#10;                            navController.navigate(&quot;onboarding&quot;) {&#10;                                popUpTo(&quot;signin&quot;) { inclusive = true }&#10;                            }&#10;                        }&#10;                    },&#10;                    onNavigateToSignUp = {&#10;                        navController.navigate(&quot;signup&quot;)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable(&quot;signup&quot;) {&#10;                SignUpScreen(&#10;                    authViewModel = authViewModel,&#10;                    onSignUpSuccess = {&#10;                        navController.navigate(&quot;onboarding&quot;) {&#10;                            popUpTo(&quot;signup&quot;) { inclusive = true }&#10;                        }&#10;                    },&#10;                    onNavigateToSignIn = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable(&quot;onboarding&quot;) {&#10;                val onboardingVM: OnboardingViewModel = hiltViewModel()&#10;                &#10;                // Store reference for permission callbacks&#10;                onboardingViewModel = onboardingVM&#10;                &#10;                OnboardingScreen(&#10;                    onboardingViewModel = onboardingVM,&#10;                    onPermissionsGranted = {&#10;                        authViewModel.completeOnboarding()&#10;                        navController.navigate(&quot;home&quot;) {&#10;                            popUpTo(&quot;onboarding&quot;) { inclusive = true }&#10;                        }&#10;                    },&#10;                    onRequestMicPermission = {&#10;                        requestMicrophonePermission.launch(Manifest.permission.RECORD_AUDIO)&#10;                    },&#10;                    onRequestUsageStatsPermission = {&#10;                        val intent = Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS)&#10;                        requestUsageStatsPermission.launch(intent)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable(&quot;home&quot;) {&#10;                HomeScreen(&#10;                    homeViewModel = hiltViewModel(),&#10;                    selectedDate = selectedDate,&#10;                    onDateChange = { selectedDate = it },&#10;                    onSearchClick = {&#10;                        navController.navigate(&quot;search&quot;)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable(&quot;search&quot;) {&#10;                SearchScreen(&#10;                    searchViewModel = hiltViewModel(),&#10;                    onBack = {&#10;                        navController.popBackStack()&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startHotwordService() {&#10;        if (hasMicrophonePermission()) {&#10;            val serviceIntent = Intent(this, HotwordDetectionService::class.java)&#10;            startForegroundService(serviceIntent)&#10;        }&#10;    }&#10;&#10;    private fun hasMicrophonePermission(): Boolean {&#10;        return ContextCompat.checkSelfPermission(&#10;            this,&#10;            Manifest.permission.RECORD_AUDIO&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;&#10;    private fun hasUsageStatsPermission(): Boolean {&#10;        val appOps = getSystemService(Context.APP_OPS_SERVICE) as AppOpsManager&#10;        val mode = appOps.checkOpNoThrow(&#10;            AppOpsManager.OPSTR_GET_USAGE_STATS,&#10;            android.os.Process.myUid(),&#10;            packageName&#10;        )&#10;        return mode == AppOpsManager.MODE_ALLOWED&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Update onboarding permissions when returning to the app&#10;        onboardingViewModel?.let { vm -&gt;&#10;            vm.setMicrophonePermission(hasMicrophonePermission())&#10;            vm.setUsageStatsPermission(hasUsageStatsPermission())&#10;            vm.checkBatteryOptimization()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/data/network/AuthApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/data/network/AuthApiService.kt" />
              <option name="originalContent" value="package com.example.diaensho.data.network&#10;&#10;import com.example.diaensho.data.network.model.*&#10;import retrofit2.http.*&#10;&#10;interface AuthApiService {&#10;    @POST(&quot;api/auth/signup&quot;)&#10;    suspend fun signUp(@Body request: SignUpRequest): AuthResponse&#10;&#10;    @POST(&quot;api/auth/signin&quot;)&#10;    suspend fun signIn(@Body request: SignInRequest): AuthResponse&#10;&#10;    @GET(&quot;api/auth/verify&quot;)&#10;    suspend fun verifyToken(@Header(&quot;Authorization&quot;) token: String): UserDto&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.data.network&#10;&#10;import com.example.diaensho.data.network.model.*&#10;import retrofit2.http.*&#10;&#10;interface AuthApiService {&#10;    @POST(&quot;api/auth/signup&quot;)&#10;    suspend fun signUp(@Body request: SignUpRequest): Map&lt;String, Any&gt;&#10;&#10;    @POST(&quot;api/auth/signin&quot;)&#10;    suspend fun signIn(@Body request: SignInRequest): Map&lt;String, Any&gt;&#10;&#10;    @GET(&quot;api/auth/verify&quot;)&#10;    suspend fun verifyToken(@Header(&quot;Authorization&quot;) token: String): UserDto&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/data/network/model/AuthDto.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/data/network/model/AuthDto.kt" />
              <option name="originalContent" value="package com.example.diaensho.data.network.model&#10;&#10;import com.squareup.moshi.Json&#10;import com.squareup.moshi.JsonClass&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class SignUpRequest(&#10;    @Json(name = &quot;username&quot;) val username: String,&#10;    @Json(name = &quot;email&quot;) val email: String,&#10;    @Json(name = &quot;password&quot;) val password: String&#10;)&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class SignInRequest(&#10;    @Json(name = &quot;email&quot;) val email: String,&#10;    @Json(name = &quot;password&quot;) val password: String&#10;)&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class AuthResponse(&#10;    @Json(name = &quot;token&quot;) val token: String,&#10;    @Json(name = &quot;user&quot;) val user: UserDto? = null&#10;)&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class UserDto(&#10;    @Json(name = &quot;id&quot;) val id: Long,&#10;    @Json(name = &quot;username&quot;) val username: String,&#10;    @Json(name = &quot;email&quot;) val email: String&#10;)&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class ApiError(&#10;    @Json(name = &quot;message&quot;) val message: String,&#10;    @Json(name = &quot;timestamp&quot;) val timestamp: String? = null,&#10;    @Json(name = &quot;status&quot;) val status: Int? = null&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.data.network.model&#10;&#10;import com.squareup.moshi.Json&#10;import com.squareup.moshi.JsonClass&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class SignUpRequest(&#10;    @Json(name = &quot;username&quot;) val username: String,&#10;    @Json(name = &quot;email&quot;) val email: String,&#10;    @Json(name = &quot;password&quot;) val password: String&#10;)&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class SignInRequest(&#10;    @Json(name = &quot;username&quot;) val username: String,  // Changed from email to username&#10;    @Json(name = &quot;password&quot;) val password: String&#10;)&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class AuthResponse(&#10;    @Json(name = &quot;token&quot;) val token: String,&#10;    @Json(name = &quot;user&quot;) val user: UserDto? = null&#10;)&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class UserDto(&#10;    @Json(name = &quot;id&quot;) val id: Long,&#10;    @Json(name = &quot;username&quot;) val username: String,&#10;    @Json(name = &quot;email&quot;) val email: String&#10;)&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class ApiError(&#10;    @Json(name = &quot;message&quot;) val message: String,&#10;    @Json(name = &quot;timestamp&quot;) val timestamp: String? = null,&#10;    @Json(name = &quot;status&quot;) val status: Int? = null&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/data/network/model/DiaryEntryDto.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/data/network/model/DiaryEntryDto.kt" />
              <option name="originalContent" value="package com.example.diaensho.data.network.model&#10;&#10;import com.squareup.moshi.Json&#10;import com.squareup.moshi.JsonClass&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class DiaryEntryDto(&#10;    @Json(name = &quot;id&quot;) val id: Long? = null,&#10;    @Json(name = &quot;text&quot;) val text: String,&#10;    @Json(name = &quot;timestamp&quot;) val timestamp: String&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.data.network.model&#10;&#10;import com.squareup.moshi.Json&#10;import com.squareup.moshi.JsonClass&#10;&#10;@JsonClass(generateAdapter = true)&#10;data class DiaryEntryDto(&#10;    @Json(name = &quot;id&quot;) val id: Long? = null,&#10;    @Json(name = &quot;text&quot;) val text: String,&#10;    @Json(name = &quot;timestamp&quot;) val timestamp: String,&#10;    @Json(name = &quot;isSynced&quot;) val isSynced: Boolean = false&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/data/repository/AuthRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/data/repository/AuthRepository.kt" />
              <option name="originalContent" value="package com.example.diaensho.data.repository&#10;&#10;import android.util.Log&#10;import com.example.diaensho.data.network.AuthApiService&#10;import com.example.diaensho.data.network.model.*&#10;import com.example.diaensho.data.preferences.AuthPreferences&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import retrofit2.HttpException&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AuthRepository @Inject constructor(&#10;    private val authApiService: AuthApiService,&#10;    private val authPreferences: AuthPreferences&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;AuthRepository&quot;&#10;    }&#10;&#10;    suspend fun signUp(username: String, email: String, password: String): Flow&lt;Result&lt;AuthResponse&gt;&gt; = flow {&#10;        emit(Result.Loading())&#10;        try {&#10;            val request = SignUpRequest(username, email, password)&#10;&#10;            // The backend only returns a token, so we create a simple response&#10;            val tokenResponse = authApiService.signUp(request)&#10;&#10;            // Extract the token from the response JSON manually since backend format differs&#10;            val token = when (tokenResponse) {&#10;                is Map&lt;*, *&gt; -&gt; tokenResponse[&quot;token&quot;] as? String&#10;                else -&gt; null&#10;            } ?: throw Exception(&quot;No token received from server&quot;)&#10;&#10;            // Save the token&#10;            authPreferences.saveAuthToken(token)&#10;&#10;            // Create a dummy user since backend doesn't return user info&#10;            // We'll extract username from the request for now&#10;            val user = UserDto(&#10;                id = 1L, // Dummy ID&#10;                username = username,&#10;                email = email&#10;            )&#10;&#10;            // Save user info locally&#10;            authPreferences.saveUserInfo(user.id, user.username, user.email)&#10;&#10;            val authResponse = AuthResponse(token = token, user = user)&#10;            emit(Result.Success(authResponse))&#10;&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;Sign up HTTP error: ${e.code()} - ${e.message()}&quot;)&#10;            val errorMessage = when (e.code()) {&#10;                400 -&gt; &quot;Invalid signup data. Please check your input.&quot;&#10;                409 -&gt; &quot;An account with this email already exists.&quot;&#10;                422 -&gt; &quot;Please check your email format and password requirements.&quot;&#10;                500 -&gt; &quot;Server error. Please try again later.&quot;&#10;                else -&gt; &quot;Signup failed: ${e.message()}&quot;&#10;            }&#10;            emit(Result.Error(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Sign up failed&quot;, e)&#10;            emit(Result.Error(&quot;Sign up failed: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;    suspend fun signIn(email: String, password: String): Flow&lt;Result&lt;AuthResponse&gt;&gt; = flow {&#10;        emit(Result.Loading())&#10;        try {&#10;            Log.d(TAG, &quot;Attempting sign in for email: $email&quot;)&#10;            val request = SignInRequest(email, password)&#10;&#10;            // The backend only returns a token, so we create a simple response&#10;            val tokenResponse = authApiService.signIn(request)&#10;            Log.d(TAG, &quot;Received token response: $tokenResponse&quot;)&#10;&#10;            // Extract the token from the response JSON manually since backend format differs&#10;            val token = when (tokenResponse) {&#10;                is Map&lt;*, *&gt; -&gt; tokenResponse[&quot;token&quot;] as? String&#10;                else -&gt; null&#10;            } ?: throw Exception(&quot;No token received from server&quot;)&#10;&#10;            Log.i(TAG, &quot;Successfully received token, saving locally&quot;)&#10;&#10;            // Save the token&#10;            authPreferences.saveAuthToken(token)&#10;&#10;            // Create basic user info from email since backend doesn't provide it during signin&#10;            val username = email.substringBefore(&quot;@&quot;)&#10;            val user = UserDto(&#10;                id = 1L, // Dummy ID - we'll get real ID from verification if available&#10;                username = username,&#10;                email = email&#10;            )&#10;&#10;            // Save user info locally&#10;            authPreferences.saveUserInfo(user.id, user.username, user.email)&#10;&#10;            val authResponse = AuthResponse(token = token, user = user)&#10;            emit(Result.Success(authResponse))&#10;&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;Sign in HTTP error: ${e.code()} - ${e.message()}&quot;)&#10;&#10;            // Clear any existing token since signin failed&#10;            authPreferences.clearAuthData()&#10;&#10;            val errorMessage = when (e.code()) {&#10;                400 -&gt; &quot;Please check your email and password.&quot;&#10;                401 -&gt; &quot;Invalid email or password. Please try again.&quot;&#10;                403 -&gt; &quot;Account access denied. This could mean:\n• Wrong password\n• Account not verified\n• Account suspended\n\nPlease check your credentials or try signing up again.&quot;&#10;                404 -&gt; &quot;Account not found. Please sign up first.&quot;&#10;                429 -&gt; &quot;Too many login attempts. Please try again later.&quot;&#10;                500 -&gt; &quot;Server error. Please try again later.&quot;&#10;                else -&gt; &quot;Sign in failed: HTTP ${e.code()}&quot;&#10;            }&#10;            emit(Result.Error(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Sign in failed&quot;, e)&#10;            authPreferences.clearAuthData()&#10;            emit(Result.Error(&quot;Sign in failed: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;    suspend fun verifyToken(): Flow&lt;Result&lt;UserDto&gt;&gt; = flow {&#10;        emit(Result.Loading())&#10;        try {&#10;            val token = authPreferences.getFormattedAuthToken()&#10;            if (token == null) {&#10;                emit(Result.Error(&quot;No token available&quot;))&#10;                return@flow&#10;            }&#10;&#10;            val user = authApiService.verifyToken(token)&#10;            authPreferences.saveUserInfo(user.id, user.username, user.email)&#10;            emit(Result.Success(user))&#10;&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;Token verification failed with HTTP ${e.code()}&quot;)&#10;            // Clear invalid token&#10;            authPreferences.clearAuthData()&#10;            emit(Result.Error(&quot;Token verification failed: ${e.message}&quot;))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Token verification failed&quot;, e)&#10;            // Clear invalid token&#10;            authPreferences.clearAuthData()&#10;            emit(Result.Error(&quot;Token verification failed: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;    fun getCurrentUser(): UserDto? {&#10;        val userId = authPreferences.getUserId()&#10;        val username = authPreferences.getUsername()&#10;        val email = authPreferences.getEmail()&#10;&#10;        return if (userId != -1L &amp;&amp; username != null &amp;&amp; email != null) {&#10;            UserDto(id = userId, username = username, email = email)&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    fun isLoggedIn(): Boolean {&#10;        val hasToken = authPreferences.getAuthToken() != null&#10;        val hasUserInfo = getCurrentUser() != null&#10;        val isLoggedInFlag = authPreferences.isLoggedIn()&#10;&#10;        Log.d(TAG, &quot;Auth status - hasToken: $hasToken, hasUserInfo: $hasUserInfo, isLoggedInFlag: $isLoggedInFlag&quot;)&#10;&#10;        return hasToken &amp;&amp; hasUserInfo &amp;&amp; isLoggedInFlag&#10;    }&#10;&#10;    fun isOnboardingCompleted(): Boolean {&#10;        return authPreferences.isOnboardingCompleted()&#10;    }&#10;&#10;    fun setOnboardingCompleted() {&#10;        authPreferences.setOnboardingCompleted(true)&#10;    }&#10;&#10;    fun signOut() {&#10;        Log.i(TAG, &quot;Signing out user&quot;)&#10;        authPreferences.clearAuthData()&#10;    }&#10;}&#10;&#10;sealed class Result&lt;out T&gt; {&#10;    data class Success&lt;out T&gt;(val data: T) : Result&lt;T&gt;()&#10;    data class Error(val message: String) : Result&lt;Nothing&gt;()&#10;    class Loading : Result&lt;Nothing&gt;()&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.data.repository&#10;&#10;import android.util.Log&#10;import com.example.diaensho.data.network.AuthApiService&#10;import com.example.diaensho.data.network.model.*&#10;import com.example.diaensho.data.preferences.AuthPreferences&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import retrofit2.HttpException&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AuthRepository @Inject constructor(&#10;    private val authApiService: AuthApiService,&#10;    private val authPreferences: AuthPreferences&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;AuthRepository&quot;&#10;    }&#10;&#10;    suspend fun signUp(username: String, email: String, password: String): Flow&lt;Result&lt;AuthResponse&gt;&gt; = flow {&#10;        emit(Result.Loading())&#10;        try {&#10;            val request = SignUpRequest(username, email, password)&#10;&#10;            // The backend only returns a token, so we create a simple response&#10;            val tokenResponse = authApiService.signUp(request)&#10;&#10;            // Extract the token from the response JSON manually since backend format differs&#10;            val token = when (tokenResponse) {&#10;                is Map&lt;*, *&gt; -&gt; tokenResponse[&quot;token&quot;] as? String&#10;                else -&gt; null&#10;            } ?: throw Exception(&quot;No token received from server&quot;)&#10;&#10;            // Save the token&#10;            authPreferences.saveAuthToken(token)&#10;&#10;            // Create a dummy user since backend doesn't return user info&#10;            // We'll extract username from the request for now&#10;            val user = UserDto(&#10;                id = 1L, // Dummy ID&#10;                username = username,&#10;                email = email&#10;            )&#10;&#10;            // Save user info locally&#10;            authPreferences.saveUserInfo(user.id, user.username, user.email)&#10;&#10;            val authResponse = AuthResponse(token = token, user = user)&#10;            emit(Result.Success(authResponse))&#10;&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;Sign up HTTP error: ${e.code()} - ${e.message()}&quot;)&#10;            val errorMessage = when (e.code()) {&#10;                400 -&gt; &quot;Invalid signup data. Please check your input.&quot;&#10;                409 -&gt; &quot;An account with this email already exists.&quot;&#10;                422 -&gt; &quot;Please check your email format and password requirements.&quot;&#10;                500 -&gt; &quot;Server error. Please try again later.&quot;&#10;                else -&gt; &quot;Signup failed: ${e.message()}&quot;&#10;            }&#10;            emit(Result.Error(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Sign up failed&quot;, e)&#10;            emit(Result.Error(&quot;Sign up failed: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;    suspend fun signIn(email: String, password: String): Flow&lt;Result&lt;AuthResponse&gt;&gt; = flow {&#10;        emit(Result.Loading())&#10;        try {&#10;            Log.d(TAG, &quot;Attempting sign in for email: $email&quot;)&#10;            &#10;            // Since backend expects username but we collect email, we'll use email as username&#10;            // This is a common pattern where email serves as the username&#10;            val request = SignInRequest(username = email, password = password)&#10;            &#10;            // The backend only returns a token, so we create a simple response&#10;            val tokenResponse = authApiService.signIn(request)&#10;            Log.d(TAG, &quot;Received token response: $tokenResponse&quot;)&#10;            &#10;            // Extract the token from the response JSON manually since backend format differs&#10;            val token = when (tokenResponse) {&#10;                is Map&lt;*, *&gt; -&gt; tokenResponse[&quot;token&quot;] as? String&#10;                else -&gt; null&#10;            } ?: throw Exception(&quot;No token received from server&quot;)&#10;            &#10;            Log.i(TAG, &quot;Successfully received token, saving locally&quot;)&#10;            &#10;            // Save the token&#10;            authPreferences.saveAuthToken(token)&#10;            &#10;            // Create basic user info from email since backend doesn't provide it during signin&#10;            val username = email.substringBefore(&quot;@&quot;)&#10;            val user = UserDto(&#10;                id = 1L, // Dummy ID - we'll get real ID from verification if available&#10;                username = email, // Use full email as username to match backend&#10;                email = email&#10;            )&#10;            &#10;            // Save user info locally&#10;            authPreferences.saveUserInfo(user.id, user.username, user.email)&#10;            &#10;            val authResponse = AuthResponse(token = token, user = user)&#10;            emit(Result.Success(authResponse))&#10;            &#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;Sign in HTTP error: ${e.code()} - ${e.message()}&quot;)&#10;            &#10;            // Clear any existing token since signin failed&#10;            authPreferences.clearAuthData()&#10;            &#10;            val errorMessage = when (e.code()) {&#10;                400 -&gt; &quot;Please check your email and password.&quot;&#10;                401 -&gt; &quot;Invalid email or password. Please try again.&quot;&#10;                403 -&gt; &quot;Account access denied. This could mean:\n• Wrong password\n• Account not found\n• Please check your credentials or try signing up again.&quot;&#10;                404 -&gt; &quot;Account not found. Please sign up first.&quot;&#10;                429 -&gt; &quot;Too many login attempts. Please try again later.&quot;&#10;                500 -&gt; &quot;Server error. Please try again later.&quot;&#10;                else -&gt; &quot;Sign in failed: HTTP ${e.code()}&quot;&#10;            }&#10;            emit(Result.Error(errorMessage))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Sign in failed&quot;, e)&#10;            authPreferences.clearAuthData()&#10;            emit(Result.Error(&quot;Sign in failed: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;    suspend fun verifyToken(): Flow&lt;Result&lt;UserDto&gt;&gt; = flow {&#10;        emit(Result.Loading())&#10;        try {&#10;            val token = authPreferences.getFormattedAuthToken()&#10;            if (token == null) {&#10;                emit(Result.Error(&quot;No token available&quot;))&#10;                return@flow&#10;            }&#10;&#10;            val user = authApiService.verifyToken(token)&#10;            authPreferences.saveUserInfo(user.id, user.username, user.email)&#10;            emit(Result.Success(user))&#10;&#10;        } catch (e: HttpException) {&#10;            Log.e(TAG, &quot;Token verification failed with HTTP ${e.code()}&quot;)&#10;            // Clear invalid token&#10;            authPreferences.clearAuthData()&#10;            emit(Result.Error(&quot;Token verification failed: ${e.message}&quot;))&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Token verification failed&quot;, e)&#10;            // Clear invalid token&#10;            authPreferences.clearAuthData()&#10;            emit(Result.Error(&quot;Token verification failed: ${e.message}&quot;))&#10;        }&#10;    }&#10;&#10;    fun getCurrentUser(): UserDto? {&#10;        val userId = authPreferences.getUserId()&#10;        val username = authPreferences.getUsername()&#10;        val email = authPreferences.getEmail()&#10;&#10;        return if (userId != -1L &amp;&amp; username != null &amp;&amp; email != null) {&#10;            UserDto(id = userId, username = username, email = email)&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    fun isLoggedIn(): Boolean {&#10;        val hasToken = authPreferences.getAuthToken() != null&#10;        val hasUserInfo = getCurrentUser() != null&#10;        val isLoggedInFlag = authPreferences.isLoggedIn()&#10;&#10;        Log.d(TAG, &quot;Auth status - hasToken: $hasToken, hasUserInfo: $hasUserInfo, isLoggedInFlag: $isLoggedInFlag&quot;)&#10;&#10;        return hasToken &amp;&amp; hasUserInfo &amp;&amp; isLoggedInFlag&#10;    }&#10;&#10;    fun isOnboardingCompleted(): Boolean {&#10;        return authPreferences.isOnboardingCompleted()&#10;    }&#10;&#10;    fun setOnboardingCompleted() {&#10;        authPreferences.setOnboardingCompleted(true)&#10;    }&#10;&#10;    fun signOut() {&#10;        Log.i(TAG, &quot;Signing out user&quot;)&#10;        authPreferences.clearAuthData()&#10;    }&#10;}&#10;&#10;sealed class Result&lt;out T&gt; {&#10;    data class Success&lt;out T&gt;(val data: T) : Result&lt;T&gt;()&#10;    data class Error(val message: String) : Result&lt;Nothing&gt;()&#10;    class Loading : Result&lt;Nothing&gt;()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/data/repository/MainRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/data/repository/MainRepository.kt" />
              <option name="originalContent" value="package com.example.diaensho.data.repository&#10;&#10;import android.util.Log&#10;import com.example.diaensho.data.db.dao.AppUsageStatDao&#10;import com.example.diaensho.data.db.dao.DiaryEntryDao&#10;import com.example.diaensho.data.db.entity.AppUsageStatEntity&#10;import com.example.diaensho.data.db.entity.DiaryEntryEntity&#10;import com.example.diaensho.data.network.DiaryApiService&#10;import com.example.diaensho.data.network.model.AppUsageStatDto&#10;import com.example.diaensho.data.network.model.DailySummaryDto&#10;import com.example.diaensho.data.network.model.DiaryEntryDto&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import kotlin.Result&#10;&#10;@Singleton&#10;class MainRepository @Inject constructor(&#10;    private val diaryEntryDao: DiaryEntryDao,&#10;    private val appUsageStatDao: AppUsageStatDao,&#10;    private val apiService: DiaryApiService&#10;) {&#10;    // Diary Entry Operations&#10;    suspend fun addDiaryEntry(text: String) {&#10;        Log.d(&quot;MainRepository&quot;, &quot;Attempting to save diary entry: '$text'&quot;)&#10;        val entry = DiaryEntryEntity(&#10;            text = text,&#10;            timestamp = LocalDateTime.now()&#10;        )&#10;        try {&#10;            val entryId = diaryEntryDao.insert(entry)&#10;            Log.i(&quot;MainRepository&quot;, &quot;Diary entry saved successfully with ID: $entryId, content: '$text'&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;MainRepository&quot;, &quot;Failed to save diary entry: '$text'&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;&#10;    fun getDiaryEntries(): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        return diaryEntryDao.getAllEntries()&#10;    }&#10;&#10;    fun getDiaryEntriesForDate(date: LocalDate): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        val startOfDay = date.atStartOfDay()&#10;        val endOfDay = date.plusDays(1).atStartOfDay()&#10;        return diaryEntryDao.getEntriesBetween(startOfDay, endOfDay)&#10;    }&#10;&#10;    fun getDiaryEntriesForDateRange(startDate: LocalDate, endDate: LocalDate): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        val startDateTime = startDate.atStartOfDay()&#10;        val endDateTime = endDate.plusDays(1).atStartOfDay()&#10;        return diaryEntryDao.getEntriesBetween(startDateTime, endDateTime)&#10;    }&#10;&#10;    // App Usage Stats Operations&#10;    suspend fun saveAppUsageStats(stats: List&lt;AppUsageStatEntity&gt;) {&#10;        appUsageStatDao.insertAll(stats)&#10;    }&#10;&#10;    fun getAppUsageStatsForDate(date: LocalDate): Flow&lt;List&lt;AppUsageStatEntity&gt;&gt; {&#10;        return appUsageStatDao.getUsageStatsForDate(date)&#10;    }&#10;&#10;    // Enhanced Synchronization Operations&#10;    suspend fun syncUnsyncedEntries() {&#10;        val unsyncedEntries = diaryEntryDao.getUnsyncedEntries()&#10;        if (unsyncedEntries.isNotEmpty()) {&#10;            try {&#10;                val dtos = unsyncedEntries.map { entity -&gt;&#10;                    DiaryEntryDto(&#10;                        text = entity.text,&#10;                        timestamp = entity.timestamp.toString()&#10;                    )&#10;                }&#10;                val syncedEntries = dtos.map { dto -&gt;&#10;                    apiService.createEntry(dto)&#10;                }&#10;                diaryEntryDao.markAsSynced(unsyncedEntries.map { it.id })&#10;            } catch (e: Exception) {&#10;                throw RuntimeException(&quot;Failed to sync diary entries&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun syncUnsyncedStats() {&#10;        val unsyncedStats = appUsageStatDao.getUnsyncedStats()&#10;        if (unsyncedStats.isNotEmpty()) {&#10;            try {&#10;                val dtos = unsyncedStats.map { stat -&gt;&#10;                    AppUsageStatDto(&#10;                        packageName = stat.packageName,&#10;                        totalTimeInForeground = stat.totalTimeInForeground,&#10;                        date = stat.date.toString()&#10;                    )&#10;                }&#10;                apiService.uploadUsageStats(dtos)&#10;                appUsageStatDao.markAsSynced(unsyncedStats.map { it.id })&#10;            } catch (e: Exception) {&#10;                throw RuntimeException(&quot;Failed to sync usage stats&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    // New Daily Summary Operations&#10;    suspend fun getDailySummary(date: LocalDate): Result&lt;DailySummaryDto&gt; {&#10;        return try {&#10;            val summary = apiService.getDailySummary(date.toString())&#10;            Result.success(summary)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    fun searchEntries(query: String, startDate: LocalDate, endDate: LocalDate): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        return diaryEntryDao.getEntriesBetween(&#10;            startTime = startDate.atStartOfDay(),&#10;            endTime = endDate.plusDays(1).atStartOfDay()&#10;        ).map { entries -&gt;&#10;            entries.filter { it.text.contains(query, ignoreCase = true) }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.data.repository&#10;&#10;import android.util.Log&#10;import com.example.diaensho.data.db.dao.AppUsageStatDao&#10;import com.example.diaensho.data.db.dao.DiaryEntryDao&#10;import com.example.diaensho.data.db.entity.AppUsageStatEntity&#10;import com.example.diaensho.data.db.entity.DiaryEntryEntity&#10;import com.example.diaensho.data.network.DiaryApiService&#10;import com.example.diaensho.data.network.model.AppUsageStatDto&#10;import com.example.diaensho.data.network.model.DailySummaryDto&#10;import com.example.diaensho.data.network.model.DiaryEntryDto&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;import retrofit2.HttpException&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import kotlin.Result&#10;&#10;@Singleton&#10;class MainRepository @Inject constructor(&#10;    private val diaryEntryDao: DiaryEntryDao,&#10;    private val appUsageStatDao: AppUsageStatDao,&#10;    private val apiService: DiaryApiService&#10;) {&#10;    // Diary Entry Operations&#10;    suspend fun addDiaryEntry(text: String) {&#10;        Log.d(&quot;MainRepository&quot;, &quot;Attempting to save diary entry: '$text'&quot;)&#10;        val entry = DiaryEntryEntity(&#10;            text = text,&#10;            timestamp = LocalDateTime.now()&#10;        )&#10;        try {&#10;            val entryId = diaryEntryDao.insert(entry)&#10;            Log.i(&quot;MainRepository&quot;, &quot;Diary entry saved successfully with ID: $entryId, content: '$text'&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;MainRepository&quot;, &quot;Failed to save diary entry: '$text'&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;&#10;    fun getDiaryEntries(): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        return diaryEntryDao.getAllEntries()&#10;    }&#10;&#10;    fun getDiaryEntriesForDate(date: LocalDate): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        val startOfDay = date.atStartOfDay()&#10;        val endOfDay = date.plusDays(1).atStartOfDay()&#10;        return diaryEntryDao.getEntriesBetween(startOfDay, endOfDay)&#10;    }&#10;&#10;    fun getDiaryEntriesForDateRange(startDate: LocalDate, endDate: LocalDate): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        val startDateTime = startDate.atStartOfDay()&#10;        val endDateTime = endDate.plusDays(1).atStartOfDay()&#10;        return diaryEntryDao.getEntriesBetween(startDateTime, endDateTime)&#10;    }&#10;&#10;    // App Usage Stats Operations&#10;    suspend fun saveAppUsageStats(stats: List&lt;AppUsageStatEntity&gt;) {&#10;        appUsageStatDao.insertAll(stats)&#10;    }&#10;&#10;    fun getAppUsageStatsForDate(date: LocalDate): Flow&lt;List&lt;AppUsageStatEntity&gt;&gt; {&#10;        return appUsageStatDao.getUsageStatsForDate(date)&#10;    }&#10;&#10;    // Enhanced Synchronization Operations&#10;    suspend fun syncUnsyncedEntries() {&#10;        val unsyncedEntries = diaryEntryDao.getUnsyncedEntries()&#10;        if (unsyncedEntries.isNotEmpty()) {&#10;            try {&#10;                val dtos = unsyncedEntries.map { entity -&gt;&#10;                    DiaryEntryDto(&#10;                        text = entity.text,&#10;                        timestamp = entity.timestamp.toString()&#10;                    )&#10;                }&#10;                val syncedEntries = dtos.map { dto -&gt;&#10;                    apiService.createEntry(dto)&#10;                }&#10;                diaryEntryDao.markAsSynced(unsyncedEntries.map { it.id })&#10;            } catch (e: HttpException) {&#10;                when (e.code()) {&#10;                    401, 403 -&gt; {&#10;                        Log.e(&quot;MainRepository&quot;, &quot;Authentication failed during sync - user needs to re-login&quot;)&#10;                        throw RuntimeException(&quot;Authentication required - please sign in again&quot;)&#10;                    }&#10;                    else -&gt; {&#10;                        Log.e(&quot;MainRepository&quot;, &quot;HTTP error during diary entries sync: ${e.code()}&quot;)&#10;                        throw RuntimeException(&quot;Failed to sync diary entries: HTTP ${e.code()}&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainRepository&quot;, &quot;Failed to sync diary entries&quot;, e)&#10;                throw RuntimeException(&quot;Failed to sync diary entries&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    suspend fun syncUnsyncedStats() {&#10;        val unsyncedStats = appUsageStatDao.getUnsyncedStats()&#10;        if (unsyncedStats.isNotEmpty()) {&#10;            try {&#10;                val dtos = unsyncedStats.map { stat -&gt;&#10;                    AppUsageStatDto(&#10;                        packageName = stat.packageName,&#10;                        totalTimeInForeground = stat.totalTimeInForeground,&#10;                        date = stat.date.toString()&#10;                    )&#10;                }&#10;                apiService.uploadUsageStats(dtos)&#10;                appUsageStatDao.markAsSynced(unsyncedStats.map { it.id })&#10;            } catch (e: HttpException) {&#10;                when (e.code()) {&#10;                    401, 403 -&gt; {&#10;                        Log.e(&quot;MainRepository&quot;, &quot;Authentication failed during sync - user needs to re-login&quot;)&#10;                        throw RuntimeException(&quot;Authentication required - please sign in again&quot;)&#10;                    }&#10;                    else -&gt; {&#10;                        Log.e(&quot;MainRepository&quot;, &quot;HTTP error during usage stats sync: ${e.code()}&quot;)&#10;                        throw RuntimeException(&quot;Failed to sync usage stats: HTTP ${e.code()}&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainRepository&quot;, &quot;Failed to sync usage stats&quot;, e)&#10;                throw RuntimeException(&quot;Failed to sync usage stats&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    // New Daily Summary Operations&#10;    suspend fun getDailySummary(date: LocalDate): Result&lt;DailySummaryDto&gt; {&#10;        return try {&#10;            val summary = apiService.getDailySummary(date.toString())&#10;            Result.success(summary)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    fun searchEntries(query: String, startDate: LocalDate, endDate: LocalDate): Flow&lt;List&lt;DiaryEntryEntity&gt;&gt; {&#10;        return diaryEntryDao.getEntriesBetween(&#10;            startTime = startDate.atStartOfDay(),&#10;            endTime = endDate.plusDays(1).atStartOfDay()&#10;        ).map { entries -&gt;&#10;            entries.filter { it.text.contains(query, ignoreCase = true) }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/di/NetworkModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/di/NetworkModule.kt" />
              <option name="originalContent" value="package com.example.diaensho.di&#10;&#10;import com.example.diaensho.data.network.AuthApiService&#10;import com.example.diaensho.data.network.DiaryApiService&#10;import com.example.diaensho.data.preferences.AuthPreferences&#10;import com.squareup.moshi.Moshi&#10;import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.Interceptor&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.moshi.MoshiConverterFactory&#10;import javax.inject.Named&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object NetworkModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthInterceptor(authPreferences: AuthPreferences): Interceptor {&#10;        return Interceptor { chain -&gt;&#10;            val originalRequest = chain.request()&#10;            val token = authPreferences.getFormattedAuthToken()&#10;&#10;            val newRequest = if (token != null &amp;&amp; !originalRequest.url.encodedPath.contains(&quot;/auth/&quot;)) {&#10;                originalRequest.newBuilder()&#10;                    .header(&quot;Authorization&quot;, token)&#10;                    .build()&#10;            } else {&#10;                originalRequest&#10;            }&#10;&#10;            chain.proceed(newRequest)&#10;        }&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    @Named(&quot;authenticated&quot;)&#10;    fun provideAuthenticatedOkHttpClient(&#10;        authInterceptor: Interceptor&#10;    ): OkHttpClient {&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(HttpLoggingInterceptor().apply {&#10;                level = HttpLoggingInterceptor.Level.BODY&#10;            })&#10;            .addInterceptor(authInterceptor)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    @Named(&quot;unauthenticated&quot;)&#10;    fun provideUnauthenticatedOkHttpClient(): OkHttpClient {&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(HttpLoggingInterceptor().apply {&#10;                level = HttpLoggingInterceptor.Level.BODY&#10;            })&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideMoshi(): Moshi {&#10;        return Moshi.Builder()&#10;            .add(KotlinJsonAdapterFactory())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    @Named(&quot;authenticated&quot;)&#10;    fun provideAuthenticatedRetrofit(&#10;        @Named(&quot;authenticated&quot;) okHttpClient: OkHttpClient,&#10;        moshi: Moshi&#10;    ): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(&quot;http://your-backend-url.com/&quot;) // Replace with your actual backend URL&#10;            .client(okHttpClient)&#10;            .addConverterFactory(MoshiConverterFactory.create(moshi))&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    @Named(&quot;unauthenticated&quot;)&#10;    fun provideUnauthenticatedRetrofit(&#10;        @Named(&quot;unauthenticated&quot;) okHttpClient: OkHttpClient,&#10;        moshi: Moshi&#10;    ): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(&quot;http://your-backend-url.com/&quot;) // Replace with your actual backend URL&#10;            .client(okHttpClient)&#10;            .addConverterFactory(MoshiConverterFactory.create(moshi))&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthApiService(@Named(&quot;unauthenticated&quot;) retrofit: Retrofit): AuthApiService {&#10;        return retrofit.create(AuthApiService::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideDiaryApiService(@Named(&quot;authenticated&quot;) retrofit: Retrofit): DiaryApiService {&#10;        return retrofit.create(DiaryApiService::class.java)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.di&#10;&#10;import com.example.diaensho.data.network.AuthApiService&#10;import com.example.diaensho.data.network.DiaryApiService&#10;import com.example.diaensho.data.preferences.AuthPreferences&#10;import com.squareup.moshi.Moshi&#10;import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.Interceptor&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.moshi.MoshiConverterFactory&#10;import javax.inject.Named&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object NetworkModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthInterceptor(authPreferences: AuthPreferences): Interceptor {&#10;        return Interceptor { chain -&gt;&#10;            val originalRequest = chain.request()&#10;            val token = authPreferences.getFormattedAuthToken()&#10;&#10;            val newRequest = if (token != null &amp;&amp; !originalRequest.url.encodedPath.contains(&quot;/auth/&quot;)) {&#10;                originalRequest.newBuilder()&#10;                    .header(&quot;Authorization&quot;, token)&#10;                    .build()&#10;            } else {&#10;                originalRequest&#10;            }&#10;&#10;            chain.proceed(newRequest)&#10;        }&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    @Named(&quot;authenticated&quot;)&#10;    fun provideAuthenticatedOkHttpClient(&#10;        authInterceptor: Interceptor&#10;    ): OkHttpClient {&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(HttpLoggingInterceptor().apply {&#10;                level = HttpLoggingInterceptor.Level.BODY&#10;            })&#10;            .addInterceptor(authInterceptor)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    @Named(&quot;unauthenticated&quot;)&#10;    fun provideUnauthenticatedOkHttpClient(): OkHttpClient {&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(HttpLoggingInterceptor().apply {&#10;                level = HttpLoggingInterceptor.Level.BODY&#10;            })&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideMoshi(): Moshi {&#10;        return Moshi.Builder()&#10;            .add(KotlinJsonAdapterFactory())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    @Named(&quot;authenticated&quot;)&#10;    fun provideAuthenticatedRetrofit(&#10;        @Named(&quot;authenticated&quot;) okHttpClient: OkHttpClient,&#10;        moshi: Moshi&#10;    ): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(&quot;https://diaensho-backend.onrender.com/&quot;)&#10;            .client(okHttpClient)&#10;            .addConverterFactory(MoshiConverterFactory.create(moshi))&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    @Named(&quot;unauthenticated&quot;)&#10;    fun provideUnauthenticatedRetrofit(&#10;        @Named(&quot;unauthenticated&quot;) okHttpClient: OkHttpClient,&#10;        moshi: Moshi&#10;    ): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(&quot;https://diaensho-backend.onrender.com/&quot;)&#10;            .client(okHttpClient)&#10;            .addConverterFactory(MoshiConverterFactory.create(moshi))&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthApiService(@Named(&quot;unauthenticated&quot;) retrofit: Retrofit): AuthApiService {&#10;        return retrofit.create(AuthApiService::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideDiaryApiService(@Named(&quot;authenticated&quot;) retrofit: Retrofit): DiaryApiService {&#10;        return retrofit.create(DiaryApiService::class.java)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/di/RepositoryModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/di/RepositoryModule.kt" />
              <option name="updatedContent" value="package com.example.diaensho.di&#10;&#10;import com.example.diaensho.data.repository.AuthRepository&#10;import com.example.diaensho.data.repository.MainRepository&#10;import com.example.diaensho.data.network.AuthApiService&#10;import com.example.diaensho.data.network.DiaryApiService&#10;import com.example.diaensho.data.preferences.AuthPreferences&#10;import com.example.diaensho.data.db.dao.AppUsageStatDao&#10;import com.example.diaensho.data.db.dao.DiaryEntryDao&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object RepositoryModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthRepository(&#10;        authApiService: AuthApiService,&#10;        authPreferences: AuthPreferences&#10;    ): AuthRepository {&#10;        return AuthRepository(authApiService, authPreferences)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideMainRepository(&#10;        diaryEntryDao: DiaryEntryDao,&#10;        appUsageStatDao: AppUsageStatDao,&#10;        apiService: DiaryApiService&#10;    ): MainRepository {&#10;        return MainRepository(diaryEntryDao, appUsageStatDao, apiService)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/di/WorkManagerModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/di/WorkManagerModule.kt" />
              <option name="updatedContent" value="package com.example.diaensho.di&#10;&#10;import android.content.Context&#10;import androidx.work.WorkManager&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object WorkManagerModule {&#10;    &#10;    @Provides&#10;    @Singleton&#10;    fun provideWorkManager(@ApplicationContext context: Context): WorkManager {&#10;        return WorkManager.getInstance(context)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/notification/NotificationHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/notification/NotificationHelper.kt" />
              <option name="originalContent" value="package com.example.diaensho.notification&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.content.Context&#10;import android.os.Build&#10;import androidx.core.app.NotificationCompat&#10;import com.example.diaensho.R&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class NotificationHelper @Inject constructor(&#10;    private val context: Context&#10;) {&#10;    companion object {&#10;        const val HOTWORD_NOTIFICATION_ID = 1001&#10;        const val SYNC_NOTIFICATION_ID = 1002&#10;        private const val HOTWORD_CHANNEL_ID = &quot;hotword_detection&quot;&#10;        private const val SYNC_CHANNEL_ID = &quot;data_sync&quot;&#10;    }&#10;&#10;    private val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;&#10;    init {&#10;        createNotificationChannels()&#10;    }&#10;&#10;    private fun createNotificationChannels() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            // Hotword detection channel&#10;            val hotwordChannel = NotificationChannel(&#10;                HOTWORD_CHANNEL_ID,&#10;                &quot;Voice Detection&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Shows when the app is listening for voice commands&quot;&#10;                setShowBadge(false)&#10;            }&#10;&#10;            // Data sync channel&#10;            val syncChannel = NotificationChannel(&#10;                SYNC_CHANNEL_ID,&#10;                &quot;Data Sync&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Shows progress of data synchronization&quot;&#10;                setShowBadge(false)&#10;            }&#10;&#10;            notificationManager.createNotificationChannels(listOf(hotwordChannel, syncChannel))&#10;        }&#10;    }&#10;&#10;    fun createHotwordNotification(status: String): Notification {&#10;        return NotificationCompat.Builder(context, HOTWORD_CHANNEL_ID)&#10;            .setContentTitle(&quot;Diaensho Voice Assistant&quot;)&#10;            .setContentText(status)&#10;            .setSmallIcon(android.R.drawable.ic_btn_speak_now)&#10;            .setOngoing(true)&#10;            .setSilent(true)&#10;            .setCategory(NotificationCompat.CATEGORY_SERVICE)&#10;            .build()&#10;    }&#10;&#10;    fun updateHotwordNotification(status: String) {&#10;        val notification = createHotwordNotification(status)&#10;        notificationManager.notify(HOTWORD_NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    fun createSyncNotification(status: String): Notification {&#10;        return NotificationCompat.Builder(context, SYNC_CHANNEL_ID)&#10;            .setContentTitle(&quot;Syncing Data&quot;)&#10;            .setContentText(status)&#10;            .setSmallIcon(android.R.drawable.stat_sys_upload)&#10;            .setOngoing(true)&#10;            .setSilent(true)&#10;            .setCategory(NotificationCompat.CATEGORY_PROGRESS)&#10;            .build()&#10;    }&#10;&#10;    fun updateSyncNotification(status: String) {&#10;        val notification = createSyncNotification(status)&#10;        notificationManager.notify(SYNC_NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    fun cancelSyncNotification() {&#10;        notificationManager.cancel(SYNC_NOTIFICATION_ID)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.notification&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.content.Context&#10;import android.os.Build&#10;import androidx.core.app.NotificationCompat&#10;import com.example.diaensho.R&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class NotificationHelper @Inject constructor(&#10;    private val context: Context&#10;) {&#10;    companion object {&#10;        const val HOTWORD_NOTIFICATION_ID = 1001&#10;        const val SYNC_NOTIFICATION_ID = 1002&#10;        private const val HOTWORD_CHANNEL_ID = &quot;hotword_detection&quot;&#10;        private const val SYNC_CHANNEL_ID = &quot;data_sync&quot;&#10;    }&#10;&#10;    private val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;&#10;    init {&#10;        createNotificationChannels()&#10;    }&#10;&#10;    private fun createNotificationChannels() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            // Hotword detection channel&#10;            val hotwordChannel = NotificationChannel(&#10;                HOTWORD_CHANNEL_ID,&#10;                &quot;Voice Detection&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Shows when the app is listening for voice commands&quot;&#10;                setShowBadge(false)&#10;            }&#10;&#10;            // Data sync channel&#10;            val syncChannel = NotificationChannel(&#10;                SYNC_CHANNEL_ID,&#10;                &quot;Data Sync&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Shows progress of data synchronization&quot;&#10;                setShowBadge(false)&#10;            }&#10;&#10;            notificationManager.createNotificationChannels(listOf(hotwordChannel, syncChannel))&#10;        }&#10;    }&#10;&#10;    fun createHotwordNotification(message: String): Notification {&#10;        return NotificationCompat.Builder(context, HOTWORD_CHANNEL_ID)&#10;            .setContentTitle(&quot;Diaensho - Voice Detection&quot;)&#10;            .setContentText(message)&#10;            .setSmallIcon(android.R.drawable.ic_btn_speak_now)&#10;            .setOngoing(true)&#10;            .setOnlyAlertOnce(true)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .build()&#10;    }&#10;&#10;    fun updateHotwordNotification(message: String) {&#10;        val notification = createHotwordNotification(message)&#10;        notificationManager.notify(HOTWORD_NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    fun createSyncNotification(message: String): Notification {&#10;        return NotificationCompat.Builder(context, SYNC_CHANNEL_ID)&#10;            .setContentTitle(&quot;Diaensho - Syncing Data&quot;)&#10;            .setContentText(message)&#10;            .setSmallIcon(android.R.drawable.stat_sys_download)&#10;            .setOngoing(true)&#10;            .setOnlyAlertOnce(true)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .build()&#10;    }&#10;&#10;    fun updateSyncNotification(message: String) {&#10;        val notification = createSyncNotification(message)&#10;        notificationManager.notify(SYNC_NOTIFICATION_ID, notification)&#10;    }&#10;&#10;    fun cancelSyncNotification() {&#10;        notificationManager.cancel(SYNC_NOTIFICATION_ID)&#10;    }&#10;&#10;    fun cancelHotwordNotification() {&#10;        notificationManager.cancel(HOTWORD_NOTIFICATION_ID)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/service/HotwordDetectionService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/service/HotwordDetectionService.kt" />
              <option name="originalContent" value="package com.example.diaensho.service&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.app.Service&#10;import android.content.Intent&#10;import android.os.IBinder&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import com.example.diaensho.audio.AudioManager&#10;import com.example.diaensho.audio.SpeechToTextManager&#10;import com.example.diaensho.audio.WakeWordDetector&#10;import com.example.diaensho.data.repository.MainRepository&#10;import com.example.diaensho.notification.NotificationHelper&#10;import com.example.diaensho.util.PowerManagerHelper&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.cancel&#10;import kotlinx.coroutines.flow.collectLatest&#10;&#10;@AndroidEntryPoint&#10;class HotwordDetectionService : Service() {&#10;    private var silenceTimeoutJob: Job? = null&#10;    private var lastSpeechTime = 0L&#10;&#10;    companion object {&#10;        private const val TAG = &quot;HotwordService&quot;&#10;        private const val END_PHRASE = &quot;that's it&quot;&#10;        private const val DIARY_RECORDING_TIMEOUT_MS = 300000L // 5 minutes&#10;        private const val SERVICE_RESTART_DELAY_MS = 5000L&#10;        private const val SILENCE_TIMEOUT_MS = 10000L // 10 seconds of silence&#10;    }&#10;&#10;    @Inject lateinit var repository: MainRepository&#10;    @Inject lateinit var notificationHelper: NotificationHelper&#10;    @Inject lateinit var powerManagerHelper: PowerManagerHelper&#10;    @Inject lateinit var audioManager: AudioManager&#10;    @Inject lateinit var wakeWordDetector: WakeWordDetector&#10;    @Inject lateinit var speechToTextManager: SpeechToTextManager&#10;&#10;    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)&#10;    private var currentState = ServiceState.IDLE&#10;    private var diaryContent = StringBuilder()&#10;    private var recordingTimeoutJob: Job? = null&#10;    private var restartJob: Job? = null&#10;&#10;    enum class ServiceState {&#10;        IDLE, LISTENING_FOR_WAKE_WORD, RECORDING_DIARY_ENTRY, PROCESSING, ERROR&#10;    }&#10;&#10;    @RequiresPermission(Manifest.permission.RECORD_AUDIO)&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        Log.i(TAG, &quot;Service created&quot;)&#10;&#10;        startForeground(&#10;            NotificationHelper.HOTWORD_NOTIFICATION_ID,&#10;            notificationHelper.createHotwordNotification(&quot;Initializing...&quot;)&#10;        )&#10;&#10;        powerManagerHelper.acquireWakeLock()&#10;        startWakeWordDetection()&#10;    }&#10;&#10;    @RequiresPermission(Manifest.permission.RECORD_AUDIO)&#10;    private fun startWakeWordDetection() {&#10;        if (currentState == ServiceState.LISTENING_FOR_WAKE_WORD) {&#10;            Log.w(TAG, &quot;Already listening for wake word&quot;)&#10;            return&#10;        }&#10;&#10;        currentState = ServiceState.LISTENING_FOR_WAKE_WORD&#10;        updateNotification(&quot;Listening for wake word...&quot;)&#10;&#10;        val success = wakeWordDetector.startListening { detectedKeyword -&gt;&#10;            Log.i(TAG, &quot;Wake word detected: $detectedKeyword&quot;)&#10;            onWakeWordDetected()&#10;        }&#10;&#10;        if (!success) {&#10;            Log.e(TAG, &quot;Failed to start wake word detection&quot;)&#10;            handleError(&quot;Failed to start wake word detection&quot;)&#10;        } else {&#10;            Log.i(TAG, &quot;Wake word detection started successfully&quot;)&#10;        }&#10;&#10;        // Monitor wake word detector state&#10;        serviceScope.launch {&#10;            wakeWordDetector.detectionState.collectLatest { state -&gt;&#10;                when (state) {&#10;                    WakeWordDetector.DetectionState.ERROR -&gt; {&#10;                        Log.e(TAG, &quot;Wake word detector error&quot;)&#10;                        handleError(&quot;Wake word detection error&quot;)&#10;                    }&#10;                    WakeWordDetector.DetectionState.LISTENING -&gt; {&#10;                        updateNotification(&quot; Listening for wake word...&quot;)&#10;                    }&#10;                    else -&gt; { /* Handle other states if needed */ }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun onWakeWordDetected() {&#10;        wakeWordDetector.stopListening()&#10;        startDiaryRecording()&#10;    }&#10;&#10;    private fun startDiaryRecording() {&#10;        currentState = ServiceState.RECORDING_DIARY_ENTRY&#10;        diaryContent.clear()&#10;        lastSpeechTime = System.currentTimeMillis()&#10;&#10;        updateNotification(&quot; Recording diary entry... Say '$END_PHRASE' when done&quot;)&#10;&#10;        // Cancel any existing timeouts&#10;        recordingTimeoutJob?.cancel()&#10;        silenceTimeoutJob?.cancel()&#10;&#10;        // Set recording timeout&#10;        recordingTimeoutJob = serviceScope.launch {&#10;            delay(DIARY_RECORDING_TIMEOUT_MS)&#10;            if (currentState == ServiceState.RECORDING_DIARY_ENTRY) {&#10;                Log.i(TAG, &quot;Diary recording timed out&quot;)&#10;                finalizeDiaryEntry(&quot;Recording timed out after 5 minutes&quot;)&#10;            }&#10;        }&#10;&#10;        // Start silence monitoring&#10;        startSilenceMonitoring()&#10;&#10;        // Start speech recognition on Main dispatcher&#10;        serviceScope.launch {&#10;            withContext(Dispatchers.Main) {&#10;                delay(3000) // 3 second delay to allow user to prepare&#10;&#10;                val success = speechToTextManager.startListening(&#10;                    onResult = { result -&gt;&#10;                        handleSpeechResult(result)&#10;                    },&#10;                    onError = { error -&gt;&#10;                        Log.e(TAG, &quot;Speech recognition error: $error&quot;)&#10;                        if (diaryContent.isNotEmpty()) {&#10;                            finalizeDiaryEntry(&quot;Recognition error, but saved content&quot;)&#10;                        } else {&#10;                            restartDiaryRecording()&#10;                        }&#10;                    },&#10;                    onComplete = {&#10;                        if (currentState == ServiceState.RECORDING_DIARY_ENTRY) {&#10;                            if (diaryContent.isNotEmpty()) {&#10;                                finalizeDiaryEntry(&quot;Recording completed&quot;)&#10;                            } else {&#10;                                restartDiaryRecording()&#10;                            }&#10;                        }&#10;                    },&#10;                    preferOffline = false,&#10;                    maxResults = 5&#10;                )&#10;&#10;                if (!success) {&#10;                    Log.e(TAG, &quot;Failed to start speech recognition&quot;)&#10;                    handleError(&quot;Failed to start speech recognition&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Monitor speech recognition state for visual feedback&#10;        serviceScope.launch {&#10;            speechToTextManager.recognitionState.collectLatest { state -&gt;&#10;                when (state) {&#10;                    SpeechToTextManager.RecognitionState.LISTENING -&gt; {&#10;                        updateNotification(&quot; Listening... Say '$END_PHRASE' when done&quot;)&#10;                    }&#10;                    SpeechToTextManager.RecognitionState.PROCESSING -&gt; {&#10;                        updateNotification(&quot;⚡ Processing speech...&quot;)&#10;                    }&#10;                    else -&gt; { /* Other states handled in callbacks */ }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Monitor audio level for visual feedback&#10;        serviceScope.launch {&#10;            speechToTextManager.confidence.collectLatest { level -&gt;&#10;                if (currentState == ServiceState.RECORDING_DIARY_ENTRY &amp;&amp; level &gt; 0.1f) {&#10;                    val indicator = &quot;▌&quot;.repeat((level * 5).toInt().coerceIn(1, 5))&#10;                    updateNotification(&quot; Recording $indicator Say '$END_PHRASE' when done&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startSilenceMonitoring() {&#10;        silenceTimeoutJob?.cancel()&#10;        silenceTimeoutJob = serviceScope.launch {&#10;            while (currentState == ServiceState.RECORDING_DIARY_ENTRY) {&#10;                delay(1000) // Check every second&#10;&#10;                val timeSinceLastSpeech = System.currentTimeMillis() - lastSpeechTime&#10;                if (timeSinceLastSpeech &gt; SILENCE_TIMEOUT_MS) {&#10;                    Log.i(TAG, &quot;Silence timeout reached&quot;)&#10;                    if (currentState == ServiceState.RECORDING_DIARY_ENTRY) {&#10;                        finalizeDiaryEntry(&quot;Silence timeout after 10 seconds&quot;)&#10;                        break&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleSpeechResult(result: SpeechToTextManager.RecognitionResult) {&#10;        val text = result.text.trim()&#10;&#10;        if (text.isEmpty()) return&#10;&#10;        Log.d(TAG, &quot;Speech result: '$text' (partial: ${result.isPartial}, confidence: ${result.confidence})&quot;)&#10;&#10;        // Update last speech time&#10;        lastSpeechTime = System.currentTimeMillis()&#10;&#10;        // Check for end phrase&#10;        if (text.lowercase().contains(END_PHRASE.lowercase())) {&#10;            Log.i(TAG, &quot;End phrase detected in: '$text'&quot;)&#10;&#10;            // Remove end phrase and finalize&#10;            val contentWithoutEndPhrase = text&#10;                .replace(END_PHRASE, &quot;&quot;, ignoreCase = true)&#10;                .trim()&#10;&#10;            if (contentWithoutEndPhrase.isNotEmpty()) {&#10;                if (diaryContent.isNotEmpty()) diaryContent.append(&quot; &quot;)&#10;                diaryContent.append(contentWithoutEndPhrase)&#10;            }&#10;&#10;            finalizeDiaryEntry(&quot;End phrase detected&quot;)&#10;            return&#10;        }&#10;&#10;        // For partial results, just update notification (don't accumulate yet)&#10;        if (result.isPartial) {&#10;            updateNotification(&quot; \&quot;$text...\&quot; Say '$END_PHRASE' when done&quot;)&#10;        } else {&#10;            // For final results, accumulate the content&#10;            if (diaryContent.isNotEmpty()) {&#10;                diaryContent.append(&quot; &quot;)&#10;            }&#10;            diaryContent.append(text)&#10;&#10;            Log.i(TAG, &quot;Final speech result added to diary: '$text'&quot;)&#10;            Log.d(TAG, &quot;Current diary content: '${diaryContent}'&quot;)&#10;&#10;            updateNotification(&quot; Recorded: \&quot;${text}\&quot; Continue or say '$END_PHRASE'&quot;)&#10;        }&#10;    }&#10;&#10;    private fun finalizeDiaryEntry(reason: String) {&#10;        // Prevent multiple simultaneous finalization attempts&#10;        if (currentState != ServiceState.RECORDING_DIARY_ENTRY) {&#10;            Log.w(TAG, &quot;Ignoring finalization attempt - not in recording state&quot;)&#10;            return&#10;        }&#10;&#10;        currentState = ServiceState.PROCESSING&#10;&#10;        // Cancel all timeouts and stop listening on main thread&#10;        recordingTimeoutJob?.cancel()&#10;        silenceTimeoutJob?.cancel()&#10;&#10;        serviceScope.launch {&#10;            withContext(Dispatchers.Main) {&#10;                try {&#10;                    speechToTextManager.stopListening()&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error stopping speech recognition&quot;, e)&#10;                }&#10;            }&#10;        }&#10;&#10;        val finalContent = diaryContent.toString().trim()&#10;&#10;        Log.i(TAG, &quot;Finalizing diary entry. Reason: $reason, Content: '$finalContent'&quot;)&#10;&#10;        if (finalContent.isNotEmpty()) {&#10;            updateNotification(&quot; Saving diary entry...&quot;)&#10;&#10;            serviceScope.launch {&#10;                try {&#10;                    repository.addDiaryEntry(finalContent)&#10;                    Log.i(TAG, &quot;Diary entry saved successfully: '$finalContent'&quot;)&#10;                    updateNotification(&quot;✅ Entry saved: \&quot;${finalContent.take(50)}${if (finalContent.length &gt; 50) &quot;...&quot; else &quot;&quot;}\&quot;&quot;)&#10;&#10;                    // Show success for a moment before restarting&#10;                    delay(3000)&#10;                    restartWakeWordDetection()&#10;&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Failed to save diary entry&quot;, e)&#10;                    updateNotification(&quot;❌ Failed to save entry&quot;)&#10;                    delay(2000)&#10;                    handleError(&quot;Failed to save diary entry: ${e.message}&quot;)&#10;                }&#10;            }&#10;        } else {&#10;            Log.w(TAG, &quot;No content to save&quot;)&#10;            updateNotification(&quot;⚠️ No content recorded&quot;)&#10;            serviceScope.launch {&#10;                delay(2000)&#10;                restartWakeWordDetection()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleError(message: String) {&#10;        // Prevent multiple simultaneous error handling&#10;        if (currentState == ServiceState.ERROR) {&#10;            Log.w(TAG, &quot;Already in error state, ignoring: $message&quot;)&#10;            return&#10;        }&#10;&#10;        Log.e(TAG, &quot;Service error: $message&quot;)&#10;        currentState = ServiceState.ERROR&#10;&#10;        // Stop all ongoing operations&#10;        recordingTimeoutJob?.cancel()&#10;        silenceTimeoutJob?.cancel()&#10;        wakeWordDetector.stopListening()&#10;&#10;        serviceScope.launch {&#10;            withContext(Dispatchers.Main) {&#10;                try {&#10;                    speechToTextManager.stopListening()&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error stopping speech recognition during error handling&quot;, e)&#10;                }&#10;            }&#10;        }&#10;&#10;        updateNotification(&quot;❌ Error: $message&quot;)&#10;&#10;        // Schedule service restart&#10;        restartJob?.cancel()&#10;        restartJob = serviceScope.launch {&#10;            delay(SERVICE_RESTART_DELAY_MS)&#10;            Log.i(TAG, &quot;Restarting service after error&quot;)&#10;            restartWakeWordDetection()&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    private fun restartWakeWordDetection() {&#10;        Log.i(TAG, &quot;Restarting wake word detection&quot;)&#10;&#10;        // Reset state&#10;        currentState = ServiceState.IDLE&#10;        diaryContent.clear()&#10;        recordingTimeoutJob?.cancel()&#10;        restartJob?.cancel()&#10;        silenceTimeoutJob?.cancel()&#10;&#10;        // Small delay to ensure clean restart&#10;        serviceScope.launch {&#10;            delay(1000)&#10;            startWakeWordDetection()&#10;        }&#10;    }&#10;&#10;    private fun restartDiaryRecording() {&#10;        Log.i(TAG, &quot;Restarting diary recording due to no speech detected&quot;)&#10;        updateNotification(&quot;⚠️ No speech detected, trying again... Speak now!&quot;)&#10;&#10;        serviceScope.launch {&#10;            withContext(Dispatchers.Main) {&#10;                delay(2000) // 2 second delay before retry&#10;&#10;                val success = speechToTextManager.startListening(&#10;                    onResult = { result -&gt;&#10;                        handleSpeechResult(result)&#10;                    },&#10;                    onError = { error -&gt;&#10;                        Log.e(TAG, &quot;Speech recognition retry error: $error&quot;)&#10;                        handleError(&quot;Speech recognition failed after retry: $error&quot;)&#10;                    },&#10;                    onComplete = {&#10;                        if (currentState == ServiceState.RECORDING_DIARY_ENTRY) {&#10;                            if (diaryContent.isNotEmpty()) {&#10;                                finalizeDiaryEntry(&quot;Recording completed&quot;)&#10;                            } else {&#10;                                Log.w(TAG, &quot;No content captured after retry&quot;)&#10;                                updateNotification(&quot;⚠️ No content recorded&quot;)&#10;                                serviceScope.launch {&#10;                                    delay(2000)&#10;                                    restartWakeWordDetection()&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    preferOffline = false,&#10;                    maxResults = 5&#10;                )&#10;&#10;                if (!success) {&#10;                    handleError(&quot;Failed to restart speech recognition&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateNotification(message: String) {&#10;        notificationHelper.updateHotwordNotification(message)&#10;    }&#10;&#10;    @RequiresPermission(Manifest.permission.RECORD_AUDIO)&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        Log.i(TAG, &quot;Service start command received&quot;)&#10;&#10;        // Ensure we're listening if not already&#10;        if (currentState == ServiceState.IDLE) {&#10;            startWakeWordDetection()&#10;        }&#10;&#10;        return START_STICKY // Restart if killed&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        Log.i(TAG, &quot;Service destroyed&quot;)&#10;&#10;        // Clean up all resources&#10;        recordingTimeoutJob?.cancel()&#10;        restartJob?.cancel()&#10;        silenceTimeoutJob?.cancel()&#10;&#10;        wakeWordDetector.release()&#10;        speechToTextManager.release()&#10;        audioManager.release()&#10;        powerManagerHelper.releaseWakeLock()&#10;&#10;        serviceScope.cancel()&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.service&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.app.Service&#10;import android.content.Intent&#10;import android.os.IBinder&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import com.example.diaensho.audio.AudioManager&#10;import com.example.diaensho.audio.SpeechToTextManager&#10;import com.example.diaensho.audio.WakeWordDetector&#10;import com.example.diaensho.data.repository.MainRepository&#10;import com.example.diaensho.notification.NotificationHelper&#10;import com.example.diaensho.util.PowerManagerHelper&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.cancel&#10;import kotlinx.coroutines.flow.collectLatest&#10;&#10;@AndroidEntryPoint&#10;class HotwordDetectionService : Service() {&#10;    private var silenceTimeoutJob: Job? = null&#10;    private var lastSpeechTime = 0L&#10;&#10;    companion object {&#10;        private const val TAG = &quot;HotwordService&quot;&#10;        private const val END_PHRASE = &quot;that's it&quot;&#10;        private const val DIARY_RECORDING_TIMEOUT_MS = 300000L // 5 minutes&#10;        private const val SERVICE_RESTART_DELAY_MS = 5000L&#10;        private const val SILENCE_TIMEOUT_MS = 10000L // 10 seconds of silence&#10;    }&#10;&#10;    @Inject lateinit var repository: MainRepository&#10;    @Inject lateinit var notificationHelper: NotificationHelper&#10;    @Inject lateinit var powerManagerHelper: PowerManagerHelper&#10;    @Inject lateinit var audioManager: AudioManager&#10;    @Inject lateinit var wakeWordDetector: WakeWordDetector&#10;    @Inject lateinit var speechToTextManager: SpeechToTextManager&#10;&#10;    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)&#10;    private var currentState = ServiceState.IDLE&#10;    private var diaryContent = StringBuilder()&#10;    private var recordingTimeoutJob: Job? = null&#10;    private var restartJob: Job? = null&#10;&#10;    enum class ServiceState {&#10;        IDLE, LISTENING_FOR_WAKE_WORD, RECORDING_DIARY_ENTRY, PROCESSING, ERROR&#10;    }&#10;&#10;    @RequiresPermission(Manifest.permission.RECORD_AUDIO)&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        Log.i(TAG, &quot;Service created&quot;)&#10;&#10;        startForeground(&#10;            NotificationHelper.HOTWORD_NOTIFICATION_ID,&#10;            notificationHelper.createHotwordNotification(&quot;Initializing...&quot;)&#10;        )&#10;&#10;        powerManagerHelper.acquireWakeLock()&#10;        startWakeWordDetection()&#10;    }&#10;&#10;    @RequiresPermission(Manifest.permission.RECORD_AUDIO)&#10;    private fun startWakeWordDetection() {&#10;        if (currentState == ServiceState.LISTENING_FOR_WAKE_WORD) {&#10;            Log.w(TAG, &quot;Already listening for wake word&quot;)&#10;            return&#10;        }&#10;&#10;        currentState = ServiceState.LISTENING_FOR_WAKE_WORD&#10;        updateNotification(&quot;Listening for wake word...&quot;)&#10;&#10;        val success = wakeWordDetector.startListening { detectedKeyword -&gt;&#10;            Log.i(TAG, &quot;Wake word detected: $detectedKeyword&quot;)&#10;            onWakeWordDetected()&#10;        }&#10;&#10;        if (!success) {&#10;            Log.e(TAG, &quot;Failed to start wake word detection&quot;)&#10;            handleError(&quot;Failed to start wake word detection&quot;)&#10;        } else {&#10;            Log.i(TAG, &quot;Wake word detection started successfully&quot;)&#10;        }&#10;&#10;        // Monitor wake word detector state&#10;        serviceScope.launch {&#10;            wakeWordDetector.detectionState.collectLatest { state -&gt;&#10;                when (state) {&#10;                    WakeWordDetector.DetectionState.ERROR -&gt; {&#10;                        Log.e(TAG, &quot;Wake word detector error&quot;)&#10;                        handleError(&quot;Wake word detection error&quot;)&#10;                    }&#10;                    WakeWordDetector.DetectionState.LISTENING -&gt; {&#10;                        updateNotification(&quot; Listening for wake word...&quot;)&#10;                    }&#10;                    else -&gt; { /* Handle other states if needed */ }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun onWakeWordDetected() {&#10;        wakeWordDetector.stopListening()&#10;        startDiaryRecording()&#10;    }&#10;&#10;    private fun startDiaryRecording() {&#10;        currentState = ServiceState.RECORDING_DIARY_ENTRY&#10;        diaryContent.clear()&#10;        lastSpeechTime = System.currentTimeMillis()&#10;&#10;        updateNotification(&quot; Recording diary entry... Say '$END_PHRASE' when done&quot;)&#10;&#10;        // Cancel any existing timeouts&#10;        recordingTimeoutJob?.cancel()&#10;        silenceTimeoutJob?.cancel()&#10;&#10;        // Set recording timeout&#10;        recordingTimeoutJob = serviceScope.launch {&#10;            delay(DIARY_RECORDING_TIMEOUT_MS)&#10;            if (currentState == ServiceState.RECORDING_DIARY_ENTRY) {&#10;                Log.i(TAG, &quot;Diary recording timed out&quot;)&#10;                finalizeDiaryEntry(&quot;Recording timed out after 5 minutes&quot;)&#10;            }&#10;        }&#10;&#10;        // Start silence monitoring&#10;        startSilenceMonitoring()&#10;&#10;        // Start speech recognition on Main dispatcher&#10;        serviceScope.launch {&#10;            withContext(Dispatchers.Main) {&#10;                delay(3000) // 3 second delay to allow user to prepare&#10;&#10;                val success = speechToTextManager.startListening(&#10;                    onResult = { result -&gt;&#10;                        handleSpeechResult(result)&#10;                    },&#10;                    onError = { error -&gt;&#10;                        Log.e(TAG, &quot;Speech recognition error: $error&quot;)&#10;                        if (diaryContent.isNotEmpty()) {&#10;                            finalizeDiaryEntry(&quot;Recognition error, but saved content&quot;)&#10;                        } else {&#10;                            restartDiaryRecording()&#10;                        }&#10;                    },&#10;                    onComplete = {&#10;                        if (currentState == ServiceState.RECORDING_DIARY_ENTRY) {&#10;                            if (diaryContent.isNotEmpty()) {&#10;                                finalizeDiaryEntry(&quot;Recording completed&quot;)&#10;                            } else {&#10;                                restartDiaryRecording()&#10;                            }&#10;                        }&#10;                    },&#10;                    preferOffline = false,&#10;                    maxResults = 5&#10;                )&#10;&#10;                if (!success) {&#10;                    Log.e(TAG, &quot;Failed to start speech recognition&quot;)&#10;                    handleError(&quot;Failed to start speech recognition&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Monitor speech recognition state for visual feedback&#10;        serviceScope.launch {&#10;            speechToTextManager.recognitionState.collectLatest { state -&gt;&#10;                when (state) {&#10;                    SpeechToTextManager.RecognitionState.LISTENING -&gt; {&#10;                        updateNotification(&quot; Listening... Say '$END_PHRASE' when done&quot;)&#10;                    }&#10;                    SpeechToTextManager.RecognitionState.PROCESSING -&gt; {&#10;                        updateNotification(&quot;⚡ Processing speech...&quot;)&#10;                    }&#10;                    else -&gt; { /* Other states handled in callbacks */ }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Monitor audio level for visual feedback&#10;        serviceScope.launch {&#10;            speechToTextManager.confidence.collectLatest { level -&gt;&#10;                if (currentState == ServiceState.RECORDING_DIARY_ENTRY &amp;&amp; level &gt; 0.1f) {&#10;                    val indicator = &quot;▌&quot;.repeat((level * 5).toInt().coerceIn(1, 5))&#10;                    updateNotification(&quot; Recording $indicator Say '$END_PHRASE' when done&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startSilenceMonitoring() {&#10;        silenceTimeoutJob?.cancel()&#10;        silenceTimeoutJob = serviceScope.launch {&#10;            while (currentState == ServiceState.RECORDING_DIARY_ENTRY) {&#10;                delay(1000) // Check every second&#10;&#10;                val timeSinceLastSpeech = System.currentTimeMillis() - lastSpeechTime&#10;                if (timeSinceLastSpeech &gt; SILENCE_TIMEOUT_MS) {&#10;                    Log.i(TAG, &quot;Silence timeout reached&quot;)&#10;                    if (currentState == ServiceState.RECORDING_DIARY_ENTRY) {&#10;                        finalizeDiaryEntry(&quot;Silence timeout after 10 seconds&quot;)&#10;                        break&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleSpeechResult(result: SpeechToTextManager.RecognitionResult) {&#10;        val text = result.text.trim()&#10;&#10;        if (text.isEmpty()) return&#10;&#10;        Log.d(TAG, &quot;Speech result: '$text' (partial: ${result.isPartial}, confidence: ${result.confidence})&quot;)&#10;&#10;        // Update last speech time&#10;        lastSpeechTime = System.currentTimeMillis()&#10;&#10;        // Check for end phrase&#10;        if (text.lowercase().contains(END_PHRASE.lowercase())) {&#10;            Log.i(TAG, &quot;End phrase detected in: '$text'&quot;)&#10;&#10;            // Remove end phrase and finalize&#10;            val contentWithoutEndPhrase = text&#10;                .replace(END_PHRASE, &quot;&quot;, ignoreCase = true)&#10;                .trim()&#10;&#10;            if (contentWithoutEndPhrase.isNotEmpty()) {&#10;                if (diaryContent.isNotEmpty()) diaryContent.append(&quot; &quot;)&#10;                diaryContent.append(contentWithoutEndPhrase)&#10;            }&#10;&#10;            finalizeDiaryEntry(&quot;End phrase detected&quot;)&#10;            return&#10;        }&#10;&#10;        // MODIFIED: Always accumulate speech content, regardless of whether it's partial or final&#10;        // This ensures we capture content even if we only get partial results&#10;        if (text.length &gt; 3) { // Only accumulate if text is meaningful (more than 3 characters)&#10;            // Update diary content with the latest speech&#10;            if (result.isPartial) {&#10;                // For partial results, update notification but also keep the content&#10;                updateNotification(&quot; \&quot;$text...\&quot; Say '$END_PHRASE' when done&quot;)&#10;                &#10;                // Update the current content (we'll use the latest partial result)&#10;                diaryContent.clear()&#10;                diaryContent.append(text)&#10;            } else {&#10;                // For final results, definitely accumulate the content&#10;                if (diaryContent.isNotEmpty()) {&#10;                    diaryContent.append(&quot; &quot;)&#10;                }&#10;                diaryContent.append(text)&#10;&#10;                Log.i(TAG, &quot;Final speech result added to diary: '$text'&quot;)&#10;                Log.d(TAG, &quot;Current diary content: '${diaryContent}'&quot;)&#10;&#10;                updateNotification(&quot; Recorded: \&quot;${text}\&quot; Continue or say '$END_PHRASE'&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun finalizeDiaryEntry(reason: String) {&#10;        // Prevent multiple simultaneous finalization attempts&#10;        if (currentState != ServiceState.RECORDING_DIARY_ENTRY) {&#10;            Log.w(TAG, &quot;Ignoring finalization attempt - not in recording state&quot;)&#10;            return&#10;        }&#10;&#10;        currentState = ServiceState.PROCESSING&#10;&#10;        // Cancel all timeouts and stop listening on main thread&#10;        recordingTimeoutJob?.cancel()&#10;        silenceTimeoutJob?.cancel()&#10;&#10;        serviceScope.launch {&#10;            withContext(Dispatchers.Main) {&#10;                try {&#10;                    speechToTextManager.stopListening()&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error stopping speech recognition&quot;, e)&#10;                }&#10;            }&#10;        }&#10;&#10;        val finalContent = diaryContent.toString().trim()&#10;&#10;        Log.i(TAG, &quot;Finalizing diary entry. Reason: $reason, Content: '$finalContent'&quot;)&#10;&#10;        if (finalContent.isNotEmpty()) {&#10;            updateNotification(&quot; Saving diary entry...&quot;)&#10;&#10;            serviceScope.launch {&#10;                try {&#10;                    repository.addDiaryEntry(finalContent)&#10;                    Log.i(TAG, &quot;Diary entry saved successfully: '$finalContent'&quot;)&#10;                    updateNotification(&quot;✅ Entry saved: \&quot;${finalContent.take(50)}${if (finalContent.length &gt; 50) &quot;...&quot; else &quot;&quot;}\&quot;&quot;)&#10;&#10;                    // Show success for a moment before restarting&#10;                    delay(3000)&#10;                    restartWakeWordDetection()&#10;&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Failed to save diary entry&quot;, e)&#10;                    updateNotification(&quot;❌ Failed to save entry&quot;)&#10;                    delay(2000)&#10;                    handleError(&quot;Failed to save diary entry: ${e.message}&quot;)&#10;                }&#10;            }&#10;        } else {&#10;            Log.w(TAG, &quot;No content to save&quot;)&#10;            updateNotification(&quot;⚠️ No content recorded&quot;)&#10;            serviceScope.launch {&#10;                delay(2000)&#10;                restartWakeWordDetection()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleError(message: String) {&#10;        // Prevent multiple simultaneous error handling&#10;        if (currentState == ServiceState.ERROR) {&#10;            Log.w(TAG, &quot;Already in error state, ignoring: $message&quot;)&#10;            return&#10;        }&#10;&#10;        Log.e(TAG, &quot;Service error: $message&quot;)&#10;        currentState = ServiceState.ERROR&#10;&#10;        // Stop all ongoing operations&#10;        recordingTimeoutJob?.cancel()&#10;        silenceTimeoutJob?.cancel()&#10;        wakeWordDetector.stopListening()&#10;&#10;        serviceScope.launch {&#10;            withContext(Dispatchers.Main) {&#10;                try {&#10;                    speechToTextManager.stopListening()&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Error stopping speech recognition during error handling&quot;, e)&#10;                }&#10;            }&#10;        }&#10;&#10;        updateNotification(&quot;❌ Error: $message&quot;)&#10;&#10;        // Schedule service restart&#10;        restartJob?.cancel()&#10;        restartJob = serviceScope.launch {&#10;            delay(SERVICE_RESTART_DELAY_MS)&#10;            Log.i(TAG, &quot;Restarting service after error&quot;)&#10;            restartWakeWordDetection()&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    private fun restartWakeWordDetection() {&#10;        Log.i(TAG, &quot;Restarting wake word detection&quot;)&#10;&#10;        // Reset state&#10;        currentState = ServiceState.IDLE&#10;        diaryContent.clear()&#10;        recordingTimeoutJob?.cancel()&#10;        restartJob?.cancel()&#10;        silenceTimeoutJob?.cancel()&#10;&#10;        // Small delay to ensure clean restart&#10;        serviceScope.launch {&#10;            delay(1000)&#10;            startWakeWordDetection()&#10;        }&#10;    }&#10;&#10;    private fun restartDiaryRecording() {&#10;        Log.i(TAG, &quot;Restarting diary recording due to no speech detected&quot;)&#10;        updateNotification(&quot;⚠️ No speech detected, trying again... Speak now!&quot;)&#10;&#10;        serviceScope.launch {&#10;            withContext(Dispatchers.Main) {&#10;                delay(2000) // 2 second delay before retry&#10;&#10;                val success = speechToTextManager.startListening(&#10;                    onResult = { result -&gt;&#10;                        handleSpeechResult(result)&#10;                    },&#10;                    onError = { error -&gt;&#10;                        Log.e(TAG, &quot;Speech recognition retry error: $error&quot;)&#10;                        handleError(&quot;Speech recognition failed after retry: $error&quot;)&#10;                    },&#10;                    onComplete = {&#10;                        if (currentState == ServiceState.RECORDING_DIARY_ENTRY) {&#10;                            if (diaryContent.isNotEmpty()) {&#10;                                finalizeDiaryEntry(&quot;Recording completed&quot;)&#10;                            } else {&#10;                                Log.w(TAG, &quot;No content captured after retry&quot;)&#10;                                updateNotification(&quot;⚠️ No content recorded&quot;)&#10;                                serviceScope.launch {&#10;                                    delay(2000)&#10;                                    restartWakeWordDetection()&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    preferOffline = false,&#10;                    maxResults = 5&#10;                )&#10;&#10;                if (!success) {&#10;                    handleError(&quot;Failed to restart speech recognition&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateNotification(message: String) {&#10;        notificationHelper.updateHotwordNotification(message)&#10;    }&#10;&#10;    @RequiresPermission(Manifest.permission.RECORD_AUDIO)&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        Log.i(TAG, &quot;Service start command received&quot;)&#10;&#10;        // Ensure we're listening if not already&#10;        if (currentState == ServiceState.IDLE) {&#10;            startWakeWordDetection()&#10;        }&#10;&#10;        return START_STICKY // Restart if killed&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        Log.i(TAG, &quot;Service destroyed&quot;)&#10;&#10;        // Clean up all resources&#10;        recordingTimeoutJob?.cancel()&#10;        restartJob?.cancel()&#10;        silenceTimeoutJob?.cancel()&#10;&#10;        wakeWordDetector.release()&#10;        speechToTextManager.release()&#10;        audioManager.release()&#10;        powerManagerHelper.releaseWakeLock()&#10;&#10;        serviceScope.cancel()&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/viewmodel/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/viewmodel/HomeViewModel.kt" />
              <option name="originalContent" value="package com.example.diaensho.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.diaensho.data.db.entity.DiaryEntryEntity&#10;import com.example.diaensho.data.db.entity.AppUsageStatEntity&#10;import com.example.diaensho.data.repository.MainRepository&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val repository: MainRepository&#10;) : ViewModel() {&#10;    private val _entries = MutableStateFlow&lt;List&lt;DiaryEntryEntity&gt;&gt;(emptyList())&#10;    val entries: StateFlow&lt;List&lt;DiaryEntryEntity&gt;&gt; = _entries.asStateFlow()&#10;&#10;    private val _appUsageStats = MutableStateFlow&lt;List&lt;AppUsageStatEntity&gt;&gt;(emptyList())&#10;    val appUsageStats: StateFlow&lt;List&lt;AppUsageStatEntity&gt;&gt; = _appUsageStats.asStateFlow()&#10;&#10;    private var currentDate: LocalDate = LocalDate.now()&#10;&#10;    init {&#10;        loadDataForDate(currentDate)&#10;    }&#10;&#10;    fun loadDataForDate(date: LocalDate) {&#10;        currentDate = date&#10;        viewModelScope.launch {&#10;            // Load diary entries&#10;            repository.getDiaryEntriesForDate(date).collect {&#10;                _entries.value = it&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            // Load app usage stats&#10;            repository.getAppUsageStatsForDate(date).collect {&#10;                _appUsageStats.value = it.sortedByDescending { stat -&gt; stat.totalTimeInForeground }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.viewmodel&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.diaensho.data.db.entity.DiaryEntryEntity&#10;import com.example.diaensho.data.db.entity.AppUsageStatEntity&#10;import com.example.diaensho.data.repository.MainRepository&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import java.time.LocalDate&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val repository: MainRepository&#10;) : ViewModel() {&#10;    private val _entries = MutableStateFlow&lt;List&lt;DiaryEntryEntity&gt;&gt;(emptyList())&#10;    val entries: StateFlow&lt;List&lt;DiaryEntryEntity&gt;&gt; = _entries.asStateFlow()&#10;&#10;    private val _appUsageStats = MutableStateFlow&lt;List&lt;AppUsageStatEntity&gt;&gt;(emptyList())&#10;    val appUsageStats: StateFlow&lt;List&lt;AppUsageStatEntity&gt;&gt; = _appUsageStats.asStateFlow()&#10;&#10;    private var currentDate: LocalDate = LocalDate.now()&#10;&#10;    init {&#10;        Log.d(&quot;HomeViewModel&quot;, &quot;Initializing HomeViewModel for date: $currentDate&quot;)&#10;        loadDataForDate(currentDate)&#10;    }&#10;&#10;    fun loadDataForDate(date: LocalDate) {&#10;        Log.d(&quot;HomeViewModel&quot;, &quot;Loading data for date: $date&quot;)&#10;        currentDate = date&#10;&#10;        viewModelScope.launch {&#10;            // Load diary entries&#10;            Log.d(&quot;HomeViewModel&quot;, &quot;Starting to load diary entries for: $date&quot;)&#10;            repository.getDiaryEntriesForDate(date).collect { entriesList -&gt;&#10;                Log.d(&quot;HomeViewModel&quot;, &quot;Received ${entriesList.size} diary entries for $date&quot;)&#10;                entriesList.forEach { entry -&gt;&#10;                    Log.v(&quot;HomeViewModel&quot;, &quot;Entry ID: ${entry.id}, Text: '${entry.text.take(50)}...', Time: ${entry.timestamp}&quot;)&#10;                }&#10;                _entries.value = entriesList&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            // Load app usage stats&#10;            Log.d(&quot;HomeViewModel&quot;, &quot;Starting to load app usage stats for: $date&quot;)&#10;            repository.getAppUsageStatsForDate(date).collect { statsList -&gt;&#10;                Log.d(&quot;HomeViewModel&quot;, &quot;Received ${statsList.size} app usage stats for $date&quot;)&#10;                _appUsageStats.value = statsList.sortedByDescending { stat -&gt; stat.totalTimeInForeground }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/work/DataSyncWorker.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/work/DataSyncWorker.kt" />
              <option name="originalContent" value="package com.example.diaensho.work&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.hilt.work.HiltWorker&#10;import androidx.work.CoroutineWorker&#10;import androidx.work.WorkerParameters&#10;import com.example.diaensho.data.repository.MainRepository&#10;import com.example.diaensho.notification.NotificationHelper&#10;import dagger.assisted.Assisted&#10;import dagger.assisted.AssistedInject&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.coroutineScope&#10;import kotlinx.coroutines.withTimeout&#10;import java.util.concurrent.TimeUnit&#10;&#10;@HiltWorker&#10;class DataSyncWorker @AssistedInject constructor(&#10;    @Assisted context: Context,&#10;    @Assisted workerParams: WorkerParameters,&#10;    private val repository: MainRepository,&#10;    private val notificationHelper: NotificationHelper&#10;) : CoroutineWorker(context, workerParams) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;DataSyncWorker&quot;&#10;        private const val SYNC_TIMEOUT_MINUTES = 10L&#10;    }&#10;&#10;    override suspend fun doWork(): Result = coroutineScope {&#10;        try {&#10;            notificationHelper.updateSyncNotification(&quot;Starting data synchronization...&quot;)&#10;&#10;            withTimeout(TimeUnit.MINUTES.toMillis(SYNC_TIMEOUT_MINUTES)) {&#10;                // Run both sync operations concurrently with proper error handling&#10;                val entriesSyncDeferred = async {&#10;                    try {&#10;                        notificationHelper.updateSyncNotification(&quot;Syncing diary entries...&quot;)&#10;                        repository.syncUnsyncedEntries()&#10;                        true&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Failed to sync diary entries&quot;, e)&#10;                        notificationHelper.updateSyncNotification(&quot;Failed to sync diary entries&quot;)&#10;                        false&#10;                    }&#10;                }&#10;&#10;                val statsSyncDeferred = async {&#10;                    try {&#10;                        notificationHelper.updateSyncNotification(&quot;Syncing app usage stats...&quot;)&#10;                        repository.syncUnsyncedStats()&#10;                        true&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Failed to sync app usage stats&quot;, e)&#10;                        notificationHelper.updateSyncNotification(&quot;Failed to sync app usage stats&quot;)&#10;                        false&#10;                    }&#10;                }&#10;&#10;                // Wait for both operations to complete&#10;                val entriesSynced = entriesSyncDeferred.await()&#10;                val statsSynced = statsSyncDeferred.await()&#10;&#10;                // Return success only if both operations succeeded&#10;                if (entriesSynced &amp;&amp; statsSynced) {&#10;                    notificationHelper.updateSyncNotification(&quot;Sync completed successfully&quot;)&#10;                    Result.success()&#10;                } else {&#10;                    notificationHelper.updateSyncNotification(&quot;Sync failed, will retry later&quot;)&#10;                    Result.retry()&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Sync operation failed or timed out&quot;, e)&#10;            notificationHelper.updateSyncNotification(&quot;Sync operation failed or timed out&quot;)&#10;            Result.retry()&#10;        } finally {&#10;            // Clear the sync notification after a delay&#10;            kotlinx.coroutines.delay(3000)&#10;            notificationHelper.cancelSyncNotification()&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.diaensho.work&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.hilt.work.HiltWorker&#10;import androidx.work.CoroutineWorker&#10;import androidx.work.WorkerParameters&#10;import com.example.diaensho.data.repository.MainRepository&#10;import com.example.diaensho.data.repository.AuthRepository&#10;import com.example.diaensho.notification.NotificationHelper&#10;import dagger.assisted.Assisted&#10;import dagger.assisted.AssistedInject&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.coroutineScope&#10;import kotlinx.coroutines.withTimeout&#10;import java.util.concurrent.TimeUnit&#10;&#10;@HiltWorker&#10;class DataSyncWorker @AssistedInject constructor(&#10;    @Assisted context: Context,&#10;    @Assisted workerParams: WorkerParameters,&#10;    private val repository: MainRepository,&#10;    private val authRepository: AuthRepository,&#10;    private val notificationHelper: NotificationHelper&#10;) : CoroutineWorker(context, workerParams) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;DataSyncWorker&quot;&#10;        private const val SYNC_TIMEOUT_MINUTES = 10L&#10;    }&#10;&#10;    override suspend fun doWork(): Result = coroutineScope {&#10;        try {&#10;            // Check if user is authenticated before attempting sync&#10;            if (!authRepository.isLoggedIn()) {&#10;                Log.w(TAG, &quot;User not authenticated - skipping sync&quot;)&#10;                notificationHelper.updateSyncNotification(&quot;Sync skipped - please sign in&quot;)&#10;                return@coroutineScope Result.success()&#10;            }&#10;&#10;            notificationHelper.updateSyncNotification(&quot;Starting data synchronization...&quot;)&#10;&#10;            withTimeout(TimeUnit.MINUTES.toMillis(SYNC_TIMEOUT_MINUTES)) {&#10;                // Run both sync operations concurrently with proper error handling&#10;                val entriesSyncDeferred = async {&#10;                    try {&#10;                        notificationHelper.updateSyncNotification(&quot;Syncing diary entries...&quot;)&#10;                        repository.syncUnsyncedEntries()&#10;                        true&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Failed to sync diary entries&quot;, e)&#10;&#10;                        // Handle authentication errors specifically&#10;                        if (e.message?.contains(&quot;Authentication required&quot;) == true) {&#10;                            Log.w(TAG, &quot;Authentication expired during sync&quot;)&#10;                            authRepository.signOut() // Clear invalid auth data&#10;                            notificationHelper.updateSyncNotification(&quot;Authentication expired - please sign in again&quot;)&#10;                            return@async false&#10;                        }&#10;&#10;                        notificationHelper.updateSyncNotification(&quot;Failed to sync diary entries&quot;)&#10;                        false&#10;                    }&#10;                }&#10;&#10;                val statsSyncDeferred = async {&#10;                    try {&#10;                        notificationHelper.updateSyncNotification(&quot;Syncing app usage stats...&quot;)&#10;                        repository.syncUnsyncedStats()&#10;                        true&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Failed to sync app usage stats&quot;, e)&#10;&#10;                        // Handle authentication errors specifically&#10;                        if (e.message?.contains(&quot;Authentication required&quot;) == true) {&#10;                            Log.w(TAG, &quot;Authentication expired during sync&quot;)&#10;                            authRepository.signOut() // Clear invalid auth data&#10;                            notificationHelper.updateSyncNotification(&quot;Authentication expired - please sign in again&quot;)&#10;                            return@async false&#10;                        }&#10;&#10;                        notificationHelper.updateSyncNotification(&quot;Failed to sync app usage stats&quot;)&#10;                        false&#10;                    }&#10;                }&#10;&#10;                // Wait for both operations to complete&#10;                val entriesSynced = entriesSyncDeferred.await()&#10;                val statsSynced = statsSyncDeferred.await()&#10;&#10;                // Return success only if both operations succeeded&#10;                if (entriesSynced &amp;&amp; statsSynced) {&#10;                    notificationHelper.updateSyncNotification(&quot;Sync completed successfully&quot;)&#10;                    Result.success()&#10;                } else if (entriesSynced || statsSynced) {&#10;                    // Partial success - some data synced&#10;                    notificationHelper.updateSyncNotification(&quot;Sync partially completed&quot;)&#10;                    Result.success()&#10;                } else {&#10;                    notificationHelper.updateSyncNotification(&quot;Sync failed, will retry later&quot;)&#10;                    Result.retry()&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Sync operation failed or timed out&quot;, e)&#10;            notificationHelper.updateSyncNotification(&quot;Sync operation failed or timed out&quot;)&#10;            Result.retry()&#10;        } finally {&#10;            // Clear the sync notification after a delay&#10;            kotlinx.coroutines.delay(3000)&#10;            notificationHelper.cancelSyncNotification()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/work/WorkManagerConfig.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/diaensho/work/WorkManagerConfig.kt" />
              <option name="updatedContent" value="package com.example.diaensho.work&#10;&#10;import android.util.Log&#10;import androidx.work.*&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class WorkManagerConfig @Inject constructor(&#10;    private val workManager: WorkManager&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;WorkManagerConfig&quot;&#10;        private const val PERIODIC_SYNC_WORK_NAME = &quot;periodic_data_sync&quot;&#10;        private const val APP_USAGE_TRACKING_WORK_NAME = &quot;app_usage_tracking&quot;&#10;    }&#10;&#10;    private var isPeriodicWorkInitialized = false&#10;&#10;    fun setupPeriodicWork() {&#10;        if (isPeriodicWorkInitialized) {&#10;            Log.d(TAG, &quot;Periodic work already initialized&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            // Setup data sync work (every 6 hours)&#10;            val syncConstraints = Constraints.Builder()&#10;                .setRequiredNetworkType(NetworkType.CONNECTED)&#10;                .setRequiresBatteryNotLow(true)&#10;                .build()&#10;&#10;            val syncWork = PeriodicWorkRequestBuilder&lt;DataSyncWorker&gt;(6, TimeUnit.HOURS)&#10;                .setConstraints(syncConstraints)&#10;                .setBackoffCriteria(&#10;                    BackoffPolicy.EXPONENTIAL,&#10;                    PeriodicWorkRequest.MIN_BACKOFF_MILLIS,&#10;                    TimeUnit.MILLISECONDS&#10;                )&#10;                .build()&#10;&#10;            // Setup app usage tracking work (daily)&#10;            val usageConstraints = Constraints.Builder()&#10;                .setRequiresBatteryNotLow(true)&#10;                .build()&#10;&#10;            val usageWork = PeriodicWorkRequestBuilder&lt;AppUsageTrackingWorker&gt;(1, TimeUnit.DAYS)&#10;                .setConstraints(usageConstraints)&#10;                .setInitialDelay(1, TimeUnit.HOURS) // Start after 1 hour&#10;                .build()&#10;&#10;            // Enqueue both work requests&#10;            workManager.enqueueUniquePeriodicWork(&#10;                PERIODIC_SYNC_WORK_NAME,&#10;                ExistingPeriodicWorkPolicy.KEEP,&#10;                syncWork&#10;            )&#10;&#10;            workManager.enqueueUniquePeriodicWork(&#10;                APP_USAGE_TRACKING_WORK_NAME,&#10;                ExistingPeriodicWorkPolicy.KEEP,&#10;                usageWork&#10;            )&#10;&#10;            isPeriodicWorkInitialized = true&#10;            Log.i(TAG, &quot;Periodic work setup completed&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to setup periodic work&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun isInitialized(): Boolean = isPeriodicWorkInitialized&#10;&#10;    fun cancelAllWork() {&#10;        workManager.cancelUniqueWork(PERIODIC_SYNC_WORK_NAME)&#10;        workManager.cancelUniqueWork(APP_USAGE_TRACKING_WORK_NAME)&#10;        isPeriodicWorkInitialized = false&#10;        Log.i(TAG, &quot;All periodic work cancelled&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/local.properties.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/local.properties.example" />
              <option name="originalContent" value="## This file is automatically generated by Android Studio.&#10;# Do not modify this file -- YOUR CHANGES WILL BE ERASED!&#10;#&#10;# This file should *NOT* be checked into Version Control Systems,&#10;# as it contains information specific to your local configuration.&#10;#&#10;# Location of the SDK. This is only used by Gradle.&#10;# For customization when using a Version Control System, please read the&#10;# header note.&#10;sdk.dir=/path/to/your/Android/Sdk&#10;&#10;# Porcupine Access Key (keep this secret)&#10;# Get your free access key from: https://console.picovoice.ai/&#10;# Copy this file to local.properties and replace with your actual key&#10;porcupine.access.key=YOUR_PORCUPINE_ACCESS_KEY_HERE&#10;" />
              <option name="updatedContent" value="# This file contains properties that should be set locally and not committed to version control&#10;# Copy this file to 'local.properties' and fill in the actual values&#10;&#10;# Android SDK location (set by Android Studio automatically)&#10;# sdk.dir=/path/to/android/sdk&#10;&#10;# Porcupine Wake Word Detection Access Key&#10;# Get your free access key from: https://console.picovoice.ai/&#10;# Sign up for a free account and create a new project to get your access key&#10;# IMPORTANT: Never commit your actual access key to version control!&#10;porcupine.access.key=YOUR_PORCUPINE_ACCESS_KEY_HERE&#10;&#10;# Backend Configuration (already set to production URL)&#10;# backend.url=https://diaensho-backend.onrender.com/&#10;&#10;# Instructions:&#10;# 1. Go to https://console.picovoice.ai/&#10;# 2. Sign up for a free account&#10;# 3. Create a new project&#10;# 4. Copy your Access Key&#10;# 5. Replace YOUR_PORCUPINE_ACCESS_KEY_HERE with your actual key&#10;# 6. Save this file as 'local.properties' (remove .example extension)&#10;# 7. Make sure 'local.properties' is in your .gitignore file" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>